<!DOCTYPE html>
<html>
  <head>
    <title>Score animation</title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="icon" href="../../favicon.png" />
    <script type="importmap" src="../../importmap.dev.importmap"></script>
    <style>
      .dice {
        width: 40px;
        height: 40px;
        background: violet;
      }

      .score-particle {
        position: fixed;
        font-family: Arial;
        font-size: 16px;
        color: gold;
        visibility: hidden;
        /* stroke: red;
        stroke-width: 2px;
        fill: black; */
      }

      .score {
        margin-top: 100px;
        margin-left: 50px;
        border: 1px solid black;
        width: 5em;
      }

      .score--value {
        display: inline-block;
        /* transform-origin: left center; */
      }
    </style>
  </head>

  <body>
    <h1>Score animation</h1>
    <p>
      Cliquer sur le bouton pour afficher une animation qui sera utilisée lorsqu'un élement de ui
      influence le score (un dé par example)
    </p>

    <div id="app"></div>
    <script type="module">
      import React from "react"
      import ReactDOM from "react-dom"
      import { printPointInDocument, getDomNodeRectangle } from "src/dom/dom.position.js"
      import { getRectangleCenterPoint } from "src/helper/rectangle.js"
      import { useSignal, useSignalState } from "src/helper/signal.js"
      import { useUpdateEffect } from "src/hooks.js"
      import { useAnimateTransitionUsingJs } from "src/animation/useAnimateTransition.js"

      const debug = false

      const Main = () => {
        return <App />
      }

      const App = () => {
        const diceNodeRef = React.useRef()
        const totalScoreDomNodeRef = React.useRef()

        const [totalScore, totalScoreSetter] = React.useState(0)
        const [scoreParticles, scoreParticlesSetter] = React.useState([])
        const [scoreParticleMergedListener, scoreParticleMergedEmitter] = useSignal()

        const [diceKept, diceKeptSetter] = React.useState(false)
        const keepCoin = () => {
          diceKeptSetter(true)
        }
        const unkeepCoin = () => {
          diceKeptSetter(false)
        }

        const [groupOfFour, groupOfFourSetter] = React.useState(false)
        const simulateGroupOfFourFound = () => {
          groupOfFourSetter(true)
        }
        const simulateGroupOfFourLost = () => {
          groupOfFourSetter(false)
        }

        return (
          <>
            <GameLogic
              diceNodeRef={diceNodeRef}
              diceKept={diceKept}
              groupOfFour={groupOfFour}
              totalScoreSetter={totalScoreSetter}
              scoreParticlesSetter={scoreParticlesSetter}
              scoreParticleMergedListener={scoreParticleMergedListener}
            />
            <Actions
              keepCoin={keepCoin}
              unkeepCoin={unkeepCoin}
              simulateGroupOfFourFound={simulateGroupOfFourFound}
              simulateGroupOfFourLost={simulateGroupOfFourLost}
            />
            <div ref={diceNodeRef} className="dice"></div>
            <Scoring
              totalScoreDomNodeRef={totalScoreDomNodeRef}
              totalScore={totalScore}
              scoreParticles={scoreParticles}
              scoreParticleMergedListener={scoreParticleMergedListener}
            />
            <ScoringParticles
              totalScoreDomNodeRef={totalScoreDomNodeRef}
              scoreParticles={scoreParticles}
              scoreParticleMergedEmitter={scoreParticleMergedEmitter}
            />
          </>
        )
      }

      const Actions = ({
        keepCoin,
        unkeepCoin,
        simulateGroupOfFourFound,
        simulateGroupOfFourLost,
      }) => {
        return (
          <>
            <button onClick={keepCoin}>Keep piece</button>
            <button onClick={unkeepCoin}>Unkeep piece</button>
            <br />
            <button
              onClick={() => {
                keepCoin()
                simulateGroupOfFourFound()
              }}
            >
              Keep 4eme piece
            </button>
            <button
              onClick={() => {
                unkeepCoin()
                simulateGroupOfFourLost()
              }}
            >
              Unkeep 4 eme piece
            </button>
          </>
        )
      }

      const GameLogic = ({
        diceNodeRef,
        diceKept,
        groupOfFour,
        totalScoreSetter,
        scoreParticlesSetter,
        scoreParticleMergedListener,
      }) => {
        const minDelayBetweenParticles = 400
        const lastParticleAnimatedMsRef = React.useRef(null)
        const addScoreParticle = ({ id, value, x, y }) => {
          const addScoreParticleToState = (scoreParticle) => {
            scoreParticlesSetter((scoreParticles) => {
              const scoreParticlesWithParticle = [...scoreParticles, scoreParticle]
              console.log(
                `adding ${scoreParticle.id}`,
                scoreParticles,
                "->",
                scoreParticlesWithParticle,
              )
              return scoreParticlesWithParticle
            })
            return () => {
              scoreParticlesSetter((scoreParticles) => {
                const scoreParticlesWithoutParticle = scoreParticles.filter(
                  (scoreParticleCandidate) => scoreParticleCandidate !== scoreParticle,
                )
                console.log(
                  `removing ${scoreParticle.id}`,
                  scoreParticles,
                  `->`,
                  scoreParticlesWithoutParticle,
                )
                return scoreParticlesWithoutParticle
              })
            }
          }

          const lastParticleAnimatedMs = lastParticleAnimatedMsRef.current
          lastParticleAnimatedMsRef.current = Date.now()
          const animationDelay = scoreParticleAnimationDelayGetter(
            lastParticleAnimatedMs,
            minDelayBetweenParticles,
          )
          console.log(`${id} animation delay is ${animationDelay}`)

          const scoreParticle = {
            id,
            value,
            x,
            y,
            animationDelay,
          }
          const removeScoreParticleFromState = addScoreParticleToState(scoreParticle)
          const stopListening = scoreParticleMergedListener((particleMerged) => {
            if (particleMerged === scoreParticle) {
              stopListening()
              removeScoreParticleFromState()
            }
          })
          return () => {
            stopListening()
            removeScoreParticleFromState()
          }
        }

        useUpdateEffect(() => {
          if (diceKept) {
            totalScoreSetter((totalScore) => {
              const to = totalScore + 100
              console.log(`dice kept, add 100 to total score -> ${to}`)
              return to
            })
            const removeScoreParticle = addScoreParticle({
              id: "coin-bonus-particle",
              value: 100,
              ...domNodeToScoreParticlePosition(diceNodeRef.current),
            })
            return () => {
              console.log("removing coin particle because dice unkept")
              removeScoreParticle()
            }
          }

          totalScoreSetter((totalScore) => {
            const to = totalScore - 100
            console.log(`dice unkept, remove 100 from total score -> ${to}`)
            return to
          })
          return () => {}
        }, [diceKept])

        useUpdateEffect(() => {
          if (groupOfFour) {
            const removeScoreParticle = addScoreParticle({
              id: "group-bonus-particle",
              value: 200,
              ...domNodeToScoreParticlePosition(diceNodeRef.current),
            })
            totalScoreSetter((totalScore) => {
              const to = totalScore + 200
              console.log(`group of four found, add 200 to total score -> ${to}`)
              return to
            })
            return () => {
              console.log("removing bonus particle because group lost")
              removeScoreParticle()
            }
          }

          totalScoreSetter((totalScore) => {
            const to = totalScore - 200
            console.log(`group of four lost, remove 200 from total score -> ${to}`)
            return to
          })
          return () => {}
        }, [groupOfFour])

        return null
      }

      const Scoring = ({
        totalScoreDomNodeRef,
        totalScore,
        scoreParticles,
        scoreParticleMergedListener,
      }) => {
        // score displayed is score without taking into account score into particles
        const totalScoreDisplayed = React.useMemo(() => {
          const scoreInParticles = scoreParticles.reduce(
            (previous, particle) => previous + particle.value,
            0,
          )
          const totalScoreWithoutParticles = totalScore - scoreInParticles
          console.log(
            `totalScoreWithoutParticles updated to ${totalScoreWithoutParticles} (totalScore is ${totalScore})`,
          )
          return totalScoreWithoutParticles
        }, [totalScore, scoreParticles])

        return (
          <TotalScore
            totalScoreDomNodeRef={totalScoreDomNodeRef}
            value={totalScoreDisplayed}
            scoreParticleMergedListener={scoreParticleMergedListener}
          />
        )
      }

      const ScoringParticles = ({
        totalScoreDomNodeRef,
        scoreParticles,
        scoreParticleMergedEmitter,
      }) => {
        return scoreParticles.map((scoreParticle) => {
          return (
            <ScoreParticle
              key={scoreParticle.id}
              totalScoreDomNodeRef={totalScoreDomNodeRef}
              scoreParticle={scoreParticle}
              scoreParticleMergedEmitter={scoreParticleMergedEmitter}
            />
          )
        })
      }

      const TotalScore = ({ value, scoreParticleMergedListener, totalScoreDomNodeRef }) => {
        const scoreParticleMerged = scoreParticleMergedListener
          ? useSignalState(scoreParticleMergedListener)
          : false

        React.useEffect(() => {
          if (!scoreParticleMerged) return

          const totalScoreDomNode = totalScoreDomNodeRef.current
          totalScoreDomNode.animate(
            [
              {
                transform: "scale(1.5)",
              },
            ],
            { duration: 300 },
          )
        }, [totalScoreDomNodeRef, scoreParticleMerged])

        const totalScoreAnimatedValue = useAnimateTransitionUsingJs(value, { duration: 600 })

        return (
          <div className="score">
            <p ref={totalScoreDomNodeRef} className="score--value">
              {totalScoreAnimatedValue ? totalScoreAnimatedValue.value : value}
            </p>
          </div>
        )
      }

      const ScoreParticle = ({
        totalScoreDomNodeRef,
        scoreParticleMergedEmitter,
        scoreParticle,
      }) => {
        const particleDomNodeRef = React.useRef()
        React.useEffect(() => {
          const particleDomNode = particleDomNodeRef.current
          const totalScoreDomNode = totalScoreDomNodeRef.current
          return animateScoreParticle({
            particleDomNode,
            totalScoreDomNode,
            x: scoreParticle.x,
            y: scoreParticle.y,
            delay: scoreParticle.animationDelay,
            oncancel: scoreParticle.onScoreParticleCanceled,
            onfinish: () => {
              scoreParticleMergedEmitter(scoreParticle)
            },
          })
        }, [])

        return (
          <div ref={particleDomNodeRef} className="score-particle">
            {scoreParticle.value}
          </div>
        )
      }

      const animateScoreParticle = ({
        particleDomNode,
        totalScoreDomNode,
        x,
        y,
        duration = 800,
        delay = 0,
        oncancel = () => {},
        onfinish = () => {},
      }) => {
        const particleDomNodeRectangle = getDomNodeRectangle(particleDomNode)
        const totalScoreDomNodeRectangle = getDomNodeRectangle(totalScoreDomNode)

        const particleWidth = particleDomNodeRectangle.right - particleDomNodeRectangle.left
        const particleHeight = particleDomNodeRectangle.bottom - particleDomNodeRectangle.top
        const startX = x - particleWidth / 2
        const startY = y - particleHeight / 2
        const intermediateX = startX + 5
        const intermediateY = startY - particleHeight * 1.5
        const endX = totalScoreDomNodeRectangle.left
        const endY = totalScoreDomNodeRectangle.top

        particleDomNode.style.left = `${startX}px`
        particleDomNode.style.top = `${startY}px`

        if (debug) {
          printPointInDocument(
            { x: startX, y: startY },
            {
              autoRemove: false,
              color: "yellow",
            },
          )
          printPointInDocument(
            { x: intermediateX, y: intermediateY },
            {
              autoRemove: false,
              color: "orange",
            },
          )
          printPointInDocument(
            { x: endX, y: endY },
            {
              autoRemove: false,
              color: "red",
            },
          )
        }

        // en premier fait apparaitre avec opacité
        const animation = particleDomNode.animate(
          [
            {
              opacity: 0,
              visibility: "visible",
              transform: "translate(0px, 0px)",
            },
            {
              offset: 0.1,
              opacity: 1,
              // transform: "translate(0px, 0px)",
            },
            {
              offset: 0.4,
              opacity: 1,
              transform: `translate(${intermediateX - startX}px, ${
                intermediateY - startY
              }px) scale(1.2)`,
            },
            {
              transform: `translate(${endX - startX}px, ${endY - startY}px) scale(1.2)`,
            },
          ],
          {
            duration,
            delay,
            fill: "forwards",
          },
        )
        animation.onfinish = () => {
          onfinish()
        }

        return () => {
          oncancel()
          animation.cancel()
        }
      }

      const scoreParticleAnimationDelayGetter = (lastAnimationMs, minDelayBetweenParticles) => {
        if (!lastAnimationMs) {
          return 0
        }

        const nowMs = Date.now()
        const msEllapsedSinceLastParticle = nowMs - lastAnimationMs
        const msToWait = minDelayBetweenParticles - msEllapsedSinceLastParticle
        if (msToWait <= 0) {
          return 0
        }

        return msToWait
      }

      const domNodeToScoreParticlePosition = (domNode) => {
        const domNodeRectangle = getDomNodeRectangle(domNode)
        const centerPoint = getRectangleCenterPoint(domNodeRectangle)
        return centerPoint
      }

      ReactDOM.render(<Main />, document.querySelector("#app"))
    </script>
  </body>
</html>
