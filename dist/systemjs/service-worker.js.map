{
  "version": 3,
  "sources": [
    "./service-worker.js"
  ],
  "names": [
    "self",
    "jsenvBuildDynamicUrls",
    "jsenvBuildStaticUrls",
    "jsenvStaticUrlsHash",
    "assets/mille-sabords.webmanifest",
    "main.prod.html",
    "config",
    "cacheName",
    "extraUrlsToCacheOnInstall",
    "extraUrlsToReloadOnInstall",
    "urlMap",
    "shouldHandleRequest",
    "request",
    "requestWasCachedOnInstall",
    "method",
    "shouldReloadOnInstall",
    "shouldCleanOnActivate",
    "response",
    "shouldCleanOtherCacheOnActivate",
    "cacheKey",
    "startsWith",
    "logLevel",
    "logsBackgroundColor",
    "navigationPreloadEnabled",
    "assertContextLooksGood",
    "undefined",
    "Array",
    "isArray",
    "TypeError",
    "Error",
    "getUtil",
    "util",
    "createLogger",
    "createLogMethod",
    "args",
    "console",
    "prefixArgs",
    "debug",
    "info",
    "warn",
    "error",
    "noop",
    "resolveUrl",
    "string",
    "String",
    "URL",
    "location",
    "toUniqueAndAbsoluteUrls",
    "urls",
    "uniqueAndAbsoluteUrls",
    "forEach",
    "url",
    "absoluteUrl",
    "includes",
    "push",
    "fetchUsingNetwork",
    "async",
    "controller",
    "AbortController",
    "signal",
    "fetch",
    "e",
    "abort",
    "responseUsesLongTermCaching",
    "responseInCache",
    "cacheControlResponseHeader",
    "headers",
    "get",
    "maxAge",
    "parseMaxAge",
    "cacheControlHeader",
    "length",
    "matches",
    "match",
    "values",
    "from",
    "tokens",
    "split",
    "key",
    "value",
    "trim",
    "toLowerCase",
    "parseDuration",
    "duration",
    "Number",
    "parseInt",
    "isFinite",
    "logger",
    "urlsToCacheOnInstall",
    "urlsToReloadOnInstall",
    "urlMapping",
    "Object",
    "keys",
    "install",
    "total",
    "installed",
    "Promise",
    "all",
    "map",
    "Request",
    "caches",
    "decideIfShoulReload",
    "requestByPassingCache",
    "cache",
    "fetchAndCache",
    "oncache",
    "stack",
    "addEventListener",
    "installEvent",
    "waitUntil",
    "handleRequest",
    "fetchEvent",
    "responseFromCache",
    "responsePreloaded",
    "preloadResponse",
    "remapRequest",
    "prototype",
    "hasOwnProperty",
    "call",
    "redirectRequest",
    "mode",
    "requestClone",
    "clone",
    "body",
    "credentials",
    "integrity",
    "referrer",
    "referrerPolicy",
    "bodyPromise",
    "resolve",
    "blob",
    "bodyValue",
    "redirect",
    "responsePromise",
    "respondWith",
    "activate",
    "enableNavigationPreloadIfPossible",
    "deleteOtherUrls",
    "deleteOtherCaches",
    "registration",
    "navigationPreload",
    "enable",
    "open",
    "requestsInCache",
    "requestInCache",
    "delete",
    "cacheKeys",
    "activateEvent",
    "activatePromise",
    "actions",
    "skipWaiting",
    "ping",
    "refreshCacheKey",
    "status",
    "addCacheKey",
    "removeCacheKey",
    "data",
    "messageEvent",
    "action",
    "actionFn",
    "actionFnReturnValue",
    "ports",
    "postMessage",
    "getCache",
    "cacheWrittenPromise",
    "put"
  ],
  "mappings": "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",
  "sourcesContent": [
    "\n\nself.jsenvBuildDynamicUrls = [\n  \"assets/ArrrMateyBb-wn3-3d20259e.ttf\",\n  \"assets/BarbeRouge-b4a9d8e9.png\",\n  \"assets/boat-dc6ca6cf.png\",\n  \"assets/CapitaineCrochet-0ce0da4f.png\",\n  \"assets/card_1skull-47b3b46a.png\",\n  \"assets/card_2skulls-61ce4149.png\",\n  \"assets/card_2sword-challenge-5c1924fd.png\",\n  \"assets/card_3sword-challenge-4097c59a.png\",\n  \"assets/card_4sword-challenge-f3927ba3.png\",\n  \"assets/card_animals-e97f74ef.png\",\n  \"assets/card_chest-037b957f.png\",\n  \"assets/card_coin-19c1c721.png\",\n  \"assets/card_default-d777c0de.png\",\n  \"assets/card_diamond-ae0da860.png\",\n  \"assets/card_pirate-57c15344.png\",\n  \"assets/card_small-1skull-3c9f4a9f.png\",\n  \"assets/card_small-2skulls-683eae22.png\",\n  \"assets/card_small-animals-b931298f.png\",\n  \"assets/card_small-chest-b171aea9.png\",\n  \"assets/card_small-coin-a99cbd8e.png\",\n  \"assets/card_small-diamond-d3b35497.png\",\n  \"assets/card_small-pirate-ada07362.png\",\n  \"assets/card_small-sword-challenge-dc6ca6cf.png\",\n  \"assets/card_small-witch-5e50e07c.png\",\n  \"assets/card_witch-24c51955.png\",\n  \"assets/card-rules-dialog-50665232.css\",\n  \"assets/character-selection-181bd1c8.css\",\n  \"assets/chest-ecf6979a.css\",\n  \"assets/cursed-grid-d5dc17c3.png\",\n  \"assets/dialog.base-81195bc9.css\",\n  \"assets/dialog-8b512a79.css\",\n  \"assets/dialog.wood-519851b1.css\",\n  \"assets/dice_coin-37896c9d.png\",\n  \"assets/dice_diamond-6c36ed54.png\",\n  \"assets/dice_monkey-044ce09c.png\",\n  \"assets/dice_parrot-21f5c4b5.png\",\n  \"assets/dice_skull-271c6b85.png\",\n  \"assets/dice_sword-f0ac96f9.png\",\n  \"assets/dice-ongoing-401ead15.css\",\n  \"assets/dice-b1c540cc.css\",\n  \"assets/draw-card-dialog-5d3f49fd.css\",\n  \"assets/favicon-25e95a00.png\",\n  \"assets/footer-4991a0c0.css\",\n  \"assets/game-configuration-ebf280f3.css\",\n  \"assets/GinetteBoulette-de6a1ce1.png\",\n  \"assets/header-4c28c2d6.css\",\n  \"assets/home-2e7e167b.css\",\n  \"assets/JackSparrow-f439b5cc.png\",\n  \"assets/loadscreen-f1f98571.css\",\n  \"assets/Luffy-59728a08.png\",\n  \"assets/main-0218d392.css\",\n  \"assets/metal-36435573.jpg\",\n  \"assets/mille-sabord-cee7f4b1.css\",\n  \"assets/MissFortune-4b135ade.png\",\n  \"assets/pirate-hook-02-3db1b696.png\",\n  \"assets/pirate-hook-02fba0b6.png\",\n  \"assets/PirateTreasureDemo-4B3MB-febb1694.otf\",\n  \"assets/pwa-icon-574c1c76.png\",\n  \"assets/round-2b248ac6.css\",\n  \"assets/round.score-00ca4100.css\",\n  \"assets/s-4e88d0d7.js\",\n  \"assets/score-board-c673d856.css\",\n  \"assets/sea-096e0699.jpg\",\n  \"assets/settings-c7b8b010.css\",\n  \"assets/skull-bottle-7c833fb2.png\",\n  \"assets/skull-island-87ab7c27.css\",\n  \"assets/skullsandcrossbones-70af14b1.ttf\",\n  \"assets/star-rain-7a40ced1.css\",\n  \"assets/start-player-round-dialog-2527853b.css\",\n  \"assets/stone-417f342b.png\",\n  \"assets/swords-disabled-124616f0.png\",\n  \"assets/treasure-map-6ec97baa.png\",\n  \"assets/win-treasure-7f39a7fa.png\",\n  \"assets/witch-label-f95d3d2f.png\",\n  \"assets/wood-box-fcdd41cc.jpg\",\n  \"assets/wood-3c23f120.jpg\",\n  \"assets/wood-1edfbf4b.png\",\n  \"assets/wood2-15862f37.png\",\n  \"App-213d4891.js\",\n  \"importmap.prod-f8cc8adf.importmap\",\n  \"main.component-63d73ce7.js\",\n  \"main-e99eaf86.js\"\n]\nself.jsenvBuildStaticUrls = [\n  \"assets/mille-sabords.webmanifest\",\n  \"main.prod.html\"\n]\nself.jsenvStaticUrlsHash = {\n  \"assets/mille-sabords.webmanifest\": \"913835fc\",\n  \"main.prod.html\": \"73dfb0c6\"\n}\n\n/* globals self, config */\nself.config = {};\nconst {\n  config\n} = self;\nconfig.cacheName = `jsenv-sw-1`;\n/**\n * Service worker will try to put all config.extraUrlsToCacheOnInstall into browser cache\n * when it is installed (installation happens once).\n * Putting an url in that list means it is mandatory for the website to work offline\n * and that it will be cached as long as service worker is alive.\n */\n\nconfig.extraUrlsToCacheOnInstall = [\"/\"];\nconfig.extraUrlsToReloadOnInstall = [\"/\"];\n/**\n * Remap urls to others.\n * Was created to ensure a request at / can be configured to\n * read and write cache at /main.html\n */\n\nconfig.urlMap = {};\n/*\n  Decides if the request must be cached or not.\n  When returning true, the response for that request will be stored into cache\n*/\n\nconfig.shouldHandleRequest = (request, {\n  requestWasCachedOnInstall\n}) => {\n  if (request.method !== \"GET\" && request.method !== \"HEAD\") return false;\n  return requestWasCachedOnInstall;\n};\n/*\n  shouldReloadOnInstall(response, request)\n\n  It is a function that will be used to decide if cache must be ignored\n  when service worker installs. When returning true service worker\n  re-fetch even if there is cache for that request, otherwise cache is reused.\n  It is called on every config.urlsToCacheOnInstall.\n  shouldReloadOnInstall is not called at all if server is sending cache-control\n  with a max-age > 0 for that request. Meaning the cache is reused in that case.\n\n  The implementation below tells to reuse cache for every url listed in\n  config.urlsToCacheOnInstall.\n*/\n\n\nconfig.shouldReloadOnInstall = () => false;\n/*\n  Whenever you change something in this file, such as config.cacheName\n  or config.urlsToCacheOnInstall, browser reinstalls the service worker.\n  When service worker activates, it is responsible to clean the cache\n  used by the previous service worker version.\n\n  This logic must be implemented using config.shouldCleanOnActivate and\n  config.shouldCleanOtherCacheOnActivate functions below.\n*/\n\n/*\n  shouldCleanOnActivate(response, request)\n\n  It is a function that will be used to decide if a cached response must be deleted\n  when service worker activates.\n\n  The implementation below tells to delete cache for any request not listed\n  in config.urlsToCacheOnInstall. It means that if an url was listed in the previous worker\n  but is not anymore it will be deleted. It also means that if a request returns true for\n  config.shouldHandleRequest and is not listed in config.urlsToCacheOnInstall, that request\n  cache will be deleted every time service worker is activated after an update.\n*/\n\n\nconfig.shouldCleanOnActivate = (response, request, {\n  requestWasCachedOnInstall\n}) => !requestWasCachedOnInstall;\n/*\n  shouldCleanOtherCacheOnActivate(cacheKey)\n\n  It is a function that will be used to decide if an existing cache must be deleted\n  when the service worker activates.\n\n  The implementation below tells to delete cache only if it starts by \"jsenv-sw\"\n  to ensure we delete only cache the we have created. It means that if you want to\n  update config.cacheName you should update jsenv-sw-1 to pjsenv-sw-2 and so on. Or update\n  shouldCleanOtherCacheOnActivate to match your custom logic.\n*/\n\n\nconfig.shouldCleanOtherCacheOnActivate = cacheKey => cacheKey.startsWith(\"jsenv-sw\");\n\nconfig.logLevel = \"warn\";\nconfig.logsBackgroundColor = \"#ffdc00\"; // nice yellow\n\nconfig.navigationPreloadEnabled = false;\nconfig.cacheName = \"mille-sabords\"; // config.logLevel = \"debug\"\n\n/* globals self, config */\nconst assertContextLooksGood = () => {\n  const {\n    jsenvBuildDynamicUrls\n  } = self;\n\n  if (jsenvBuildDynamicUrls === undefined) {\n    self.jsenvBuildDynamicUrls = [];\n  } else if (!Array.isArray(jsenvBuildDynamicUrls)) {\n    throw new TypeError(`self.jsenvBuildDynamicUrls should be an array, got ${jsenvBuildDynamicUrls}`);\n  }\n\n  const {\n    jsenvBuildStaticUrls\n  } = self;\n\n  if (jsenvBuildStaticUrls === undefined) {\n    self.jsenvBuildStaticUrls = [];\n  } else if (!Array.isArray(jsenvBuildStaticUrls)) {\n    throw new TypeError(`self.jsenvBuildStaticUrls should be an array, got ${jsenvBuildStaticUrls}`);\n  }\n\n  if (typeof config === undefined) {\n    throw new Error(`config is not in scope, be sure to import sw.preconfig.js before sw.jsenv.js`);\n  }\n\n  const {\n    cacheName\n  } = config;\n\n  if (typeof cacheName !== \"string\") {\n    throw new TypeError(`config.cacheName should be a string, got ${cacheName}`);\n  }\n\n  const {\n    extraUrlsToCacheOnInstall\n  } = config;\n\n  if (!Array.isArray(extraUrlsToCacheOnInstall)) {\n    throw new TypeError(`config.extraUrlsToCacheOnInstall should be an array, got ${extraUrlsToCacheOnInstall}`);\n  }\n\n  const {\n    extraUrlsToReloadOnInstall\n  } = config;\n\n  if (!Array.isArray(extraUrlsToReloadOnInstall)) {\n    throw new TypeError(`config.extraUrlsToReloadOnInstall should be an array, got ${extraUrlsToReloadOnInstall}`);\n  }\n\n  const {\n    urlMap\n  } = config;\n\n  if (typeof urlMap !== \"object\") {\n    throw new TypeError(`config.urlMap should be an object, got ${urlMap}`);\n  }\n\n  const {\n    shouldReloadOnInstall\n  } = config;\n\n  if (typeof shouldReloadOnInstall !== \"function\") {\n    throw new TypeError(`config.shouldReloadOnInstall should be a function, got ${shouldReloadOnInstall}`);\n  }\n\n  const {\n    shouldCleanOnActivate\n  } = config;\n\n  if (typeof shouldCleanOnActivate !== \"function\") {\n    throw new TypeError(`config.shouldCleanOnActivate should be a function, got ${shouldCleanOnActivate}`);\n  }\n\n  const {\n    shouldCleanOtherCacheOnActivate\n  } = config;\n\n  if (typeof shouldCleanOtherCacheOnActivate !== \"function\") {\n    throw new TypeError(`config.shouldCleanOtherCacheOnActivate should be a function, got ${shouldCleanOtherCacheOnActivate}`);\n  }\n\n  const {\n    shouldHandleRequest\n  } = config;\n\n  if (typeof shouldHandleRequest !== \"function\") {\n    throw new TypeError(`config.shouldHandleRequest should be a function, got ${shouldHandleRequest}`);\n  }\n\n  const {\n    logLevel\n  } = config;\n\n  if (typeof logLevel !== \"string\") {\n    throw new TypeError(`config.logLevel should be a boolean, got ${logLevel}`);\n  }\n\n  const {\n    logsBackgroundColor\n  } = config;\n\n  if (typeof logsBackgroundColor !== \"string\") {\n    throw new TypeError(`config.logsBackgroundColor should be a string, got ${logsBackgroundColor}`);\n  }\n\n  const {\n    navigationPreloadEnabled\n  } = config;\n\n  if (typeof navigationPreloadEnabled !== \"boolean\") {\n    throw new TypeError(`config.navigationPreloadEnabled should be a boolean, got ${navigationPreloadEnabled}`);\n  }\n};\n/*\n * util is an object holding utility functions.\n * The utility concept was added just to structure a bit this file.\n * When a utility need private helpers function, it's wrapped in {}\n * to highlight that thoose are private functions\n * The {} pattern was choosed because it allows to have private helpers\n * such as parseMaxAge. Not possible to do that with a plain object.\n */\n\n\nconst getUtil = () => {\n  const util = {};\n\n  util.createLogger = ({\n    logLevel,\n    logsBackgroundColor\n  }) => {\n    const prefixArgs = (...args) => {\n      return [`%csw`, `background: ${logsBackgroundColor}; color: black; padding: 1px 3px; margin: 0 1px`, ...args];\n    };\n\n    const createLogMethod = method => (...args) => console[method](...prefixArgs(...args));\n\n    const debug = createLogMethod(\"debug\");\n    const info = createLogMethod(\"info\");\n    const warn = createLogMethod(\"warn\");\n    const error = createLogMethod(\"error\");\n\n    const noop = () => {};\n\n    if (logLevel === \"debug\") {\n      return {\n        debug,\n        info,\n        warn,\n        error\n      };\n    }\n\n    if (logLevel === \"info\") {\n      return {\n        debug: noop,\n        info,\n        warn,\n        error\n      };\n    }\n\n    if (logLevel === \"warn\") {\n      return {\n        debug: noop,\n        info: noop,\n        warn,\n        error\n      };\n    }\n\n    if (logLevel === \"error\") {\n      return {\n        debug: noop,\n        info: noop,\n        warn: noop,\n        error\n      };\n    }\n\n    if (logLevel === \"off\") {\n      return {\n        debug: noop,\n        info: noop,\n        warn: noop,\n        error: noop\n      };\n    }\n\n    throw new Error(`unknown logLevel, got ${logLevel}`);\n  };\n\n  util.resolveUrl = string => String(new URL(string, self.location));\n\n  util.toUniqueAndAbsoluteUrls = urls => {\n    const uniqueAndAbsoluteUrls = [];\n    urls.forEach(url => {\n      const absoluteUrl = util.resolveUrl(url);\n\n      if (!uniqueAndAbsoluteUrls.includes(absoluteUrl)) {\n        uniqueAndAbsoluteUrls.push(absoluteUrl);\n      }\n    });\n    return uniqueAndAbsoluteUrls;\n  };\n\n  util.fetchUsingNetwork = async request => {\n    const controller = new AbortController();\n    const {\n      signal\n    } = controller;\n\n    try {\n      const response = await fetch(request, {\n        signal\n      });\n      return response;\n    } catch (e) {\n      // abort request in any case\n      // I don't know how useful this is ?\n      controller.abort();\n      throw e;\n    }\n  };\n\n  {\n    util.responseUsesLongTermCaching = responseInCache => {\n      const cacheControlResponseHeader = responseInCache.headers.get(\"cache-control\");\n      const maxAge = parseMaxAge(cacheControlResponseHeader);\n      return maxAge && maxAge > 0;\n    }; // https://github.com/tusbar/cache-control\n\n\n    const parseMaxAge = cacheControlHeader => {\n      if (!cacheControlHeader || cacheControlHeader.length === 0) return null;\n      const HEADER_REGEXP = /([a-zA-Z][a-zA-Z_-]*)\\s*(?:=(?:\"([^\"]*)\"|([^ \\t\",;]*)))?/g;\n      const matches = cacheControlHeader.match(HEADER_REGEXP) || [];\n      const values = {};\n      Array.from(matches).forEach(match => {\n        const tokens = match.split(\"=\", 2);\n        const [key] = tokens;\n        let value = null;\n\n        if (tokens.length > 1) {\n          value = tokens[1].trim();\n        }\n\n        values[key.toLowerCase()] = value;\n      });\n      return parseDuration(values[\"max-age\"]);\n    };\n\n    const parseDuration = value => {\n      if (!value) {\n        return null;\n      }\n\n      const duration = Number.parseInt(value, 10);\n\n      if (!Number.isFinite(duration) || duration < 0) {\n        return null;\n      }\n\n      return duration;\n    };\n  }\n  return util;\n};\n\nassertContextLooksGood();\nconst util = getUtil();\nconst logger = util.createLogger(config);\nconst urlsToCacheOnInstall = util.toUniqueAndAbsoluteUrls([...self.jsenvBuildDynamicUrls, ...self.jsenvBuildStaticUrls, ...config.extraUrlsToCacheOnInstall]);\nconst urlsToReloadOnInstall = util.toUniqueAndAbsoluteUrls([...self.jsenvBuildStaticUrls, ...config.extraUrlsToReloadOnInstall]);\nconst urlMapping = {};\nObject.keys(config.urlMap).forEach(key => {\n  urlMapping[util.resolveUrl(key)] = util.resolveUrl(config.urlMap[key]);\n}); // --- installation phase ---\n\nconst install = async () => {\n  logger.debug(\"install start\");\n\n  try {\n    const total = urlsToCacheOnInstall.length;\n    let installed = 0;\n    await Promise.all(urlsToCacheOnInstall.map(async url => {\n      try {\n        const request = new Request(url);\n        const responseInCache = await caches.match(request);\n\n        if (responseInCache) {\n          if (decideIfShoulReload(responseInCache, request)) {\n            logger.info(`${request.url} in cache but should be reloaded`);\n            const requestByPassingCache = new Request(url, {\n              cache: \"reload\"\n            });\n            await fetchAndCache(requestByPassingCache, {\n              oncache: () => {\n                installed += 1;\n              }\n            });\n          } else {\n            logger.debug(`${request.url} already in cache`);\n            installed += 1;\n          }\n        } else {\n          await fetchAndCache(request, {\n            oncache: () => {\n              installed += 1;\n            }\n          });\n        }\n      } catch (e) {\n        logger.warn(`cannot put ${url} in cache due to error while fetching: ${e.stack}`);\n      }\n    }));\n\n    if (installed === total) {\n      logger.debug(`install done (${total} urls added in cache)`);\n    } else {\n      logger.debug(`install done (${installed}/${total} urls added in cache)`);\n    }\n  } catch (error) {\n    logger.error(`install error: ${error.stack}`);\n  }\n};\n\nconst decideIfShoulReload = (responseInCache, request) => {\n  // if (request.mode === \"navigate\") {\n  //   return false\n  // }\n  const responseUsesLongTermCaching = util.responseUsesLongTermCaching(responseInCache);\n\n  if (responseUsesLongTermCaching) {\n    return false;\n  }\n\n  const requestUrlsInUrlsToReloadOnInstall = urlsToReloadOnInstall.includes(request.url);\n\n  if (requestUrlsInUrlsToReloadOnInstall) {\n    return true;\n  }\n\n  const shouldReload = config.shouldReloadOnInstall(responseInCache, request, {\n    requestWasCachedOnInstall: urlsToCacheOnInstall.includes(request.url)\n  });\n  return shouldReload;\n};\n\nself.addEventListener(\"install\", installEvent => {\n  installEvent.waitUntil(install(installEvent));\n}); // --- fetch implementation ---\n\nconst handleRequest = async (request, fetchEvent) => {\n  logger.debug(`received fetch event for ${request.url}`);\n\n  try {\n    const responseFromCache = await caches.match(request);\n\n    if (responseFromCache) {\n      logger.debug(`respond with response from cache for ${request.url}`);\n      return responseFromCache;\n    }\n\n    const responsePreloaded = await fetchEvent.preloadResponse;\n\n    if (responsePreloaded) {\n      logger.debug(`respond with preloaded response for ${request.url}`);\n      return responsePreloaded;\n    }\n  } catch (error) {\n    logger.warn(`error while trying to use cache for ${request.url}`, error.stack);\n    return fetch(request);\n  }\n\n  logger.debug(`no cache for ${request.url}, fetching it`);\n  return fetchAndCache(request);\n};\n\nconst remapRequest = request => {\n  if (Object.prototype.hasOwnProperty.call(urlMapping, request.url)) {\n    return redirectRequest(request, urlMapping[request.url]);\n  }\n\n  return request;\n};\n\nconst redirectRequest = async (request, url) => {\n  const {\n    mode\n  } = request;\n  logger.debug(`redirect request from ${request.url} to ${url}`); // see https://github.com/GoogleChrome/workbox/issues/1796\n\n  if (mode !== \"navigate\") {\n    return new Request(url, request);\n  }\n\n  const requestClone = request.clone();\n  const {\n    body,\n    credentials,\n    headers,\n    integrity,\n    referrer,\n    referrerPolicy\n  } = requestClone;\n  const bodyPromise = body ? Promise.resolve(body) : requestClone.blob();\n  const bodyValue = await bodyPromise;\n  const requestMutated = new Request(url, {\n    body: bodyValue,\n    credentials,\n    headers,\n    integrity,\n    referrer,\n    referrerPolicy,\n    mode: \"same-origin\",\n    redirect: \"manual\"\n  });\n  return requestMutated;\n};\n\nself.addEventListener(\"fetch\", fetchEvent => {\n  const request = remapRequest(fetchEvent.request);\n\n  if (config.shouldHandleRequest(request, {\n    requestWasCachedOnInstall: urlsToCacheOnInstall.includes(request.url)\n  })) {\n    const responsePromise = handleRequest(request, fetchEvent);\n\n    if (responsePromise) {\n      fetchEvent.respondWith(responsePromise);\n    }\n  }\n}); // --- activation phase ---\n\nconst activate = async () => {\n  logger.debug(\"activate start\");\n  await Promise.all([enableNavigationPreloadIfPossible(), deleteOtherUrls(), deleteOtherCaches()]);\n  logger.debug(\"activate done\");\n};\n\nconst enableNavigationPreloadIfPossible = async () => {\n  if (config.navigationPreloadEnabled && self.registration.navigationPreload) {\n    await self.registration.navigationPreload.enable();\n  }\n};\n\nconst deleteOtherUrls = async () => {\n  const cache = await caches.open(config.cacheName);\n  const requestsInCache = await cache.keys();\n  await Promise.all(requestsInCache.map(async requestInCache => {\n    const responseInCache = await cache.match(requestInCache);\n\n    if (config.shouldCleanOnActivate(responseInCache, requestInCache, {\n      requestWasCachedOnInstall: urlsToCacheOnInstall.includes(requestInCache.url)\n    })) {\n      logger.debug(`delete ${requestInCache.url}`);\n      await cache.delete(requestInCache);\n    }\n  }));\n};\n\nconst deleteOtherCaches = async () => {\n  const cacheKeys = await caches.keys();\n  await Promise.all(cacheKeys.map(async cacheKey => {\n    if (cacheKey !== config.cacheName && config.shouldCleanOtherCacheOnActivate(cacheKey)) {\n      logger.debug(`delete cache ${cacheKey}`);\n      await caches.delete(cacheKey);\n    }\n  }));\n};\n\nself.addEventListener(\"activate\", activateEvent => {\n  const activatePromise = activate(activateEvent);\n\n  if (activatePromise) {\n    activateEvent.waitUntil(activatePromise);\n  }\n}); // --- postMessage communication ---\n\nconst actions = {\n  skipWaiting: () => {\n    self.skipWaiting();\n  },\n  ping: () => \"pong\",\n  refreshCacheKey: async url => {\n    url = String(new URL(url, self.location));\n    const response = await fetchAndCache(new Request(url, {\n      cache: \"reload\"\n    }));\n    return response.status;\n  },\n  addCacheKey: async url => {\n    url = String(new URL(url, self.location));\n    const response = await fetchAndCache(url);\n    return response.status;\n  },\n  removeCacheKey: async url => {\n    url = String(new URL(url, self.location));\n    const cache = await caches.open(config.cacheName);\n    const deleted = await cache.delete(url);\n    return deleted;\n  }\n};\nself.addEventListener(\"message\", async messageEvent => {\n  const {\n    data\n  } = messageEvent;\n  if (typeof data !== \"object\") return;\n  const {\n    action\n  } = data;\n  const actionFn = actions[action];\n  if (!actionFn) return;\n  const {\n    args = []\n  } = data;\n  let status;\n  let value;\n\n  try {\n    const actionFnReturnValue = await actionFn(...args);\n    status = \"resolved\";\n    value = actionFnReturnValue;\n  } catch (e) {\n    status = \"rejected\";\n    value = e;\n  }\n\n  messageEvent.ports[0].postMessage({\n    status,\n    value\n  });\n}); // ---- utils ----\n\nconst caches = self.caches;\nlet cache;\n\nconst getCache = async () => {\n  if (cache) return cache;\n  cache = await caches.open(config.cacheName);\n  return cache;\n};\n\nconst fetchAndCache = async (request, {\n  oncache\n} = {}) => {\n  const [response, cache] = await Promise.all([util.fetchUsingNetwork(request), getCache()]);\n\n  if (response.status === 200) {\n    logger.debug(`fresh response found for ${request.url}, put it in cache and respond with it`);\n    const cacheWrittenPromise = cache.put(request, response.clone());\n\n    if (oncache) {\n      await cacheWrittenPromise;\n      oncache();\n    }\n\n    return response;\n  }\n\n  logger.warn(`cannot put ${request.url} in cache due to response status (${response.status})`);\n  return response;\n};"
  ]
}