<!DOCTYPE html>
<html>
  <head>
    <title>Score animation</title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="icon" href="../../favicon.png" />
    <script type="importmap" src="../../importmap.dev.importmap"></script>
    <style>
      .dice {
        width: 40px;
        height: 40px;
        background: violet;
      }

      .score-particle {
        position: absolute;
        font-family: Arial;
        font-size: 16px;
        color: gold;
        /* stroke: red;
        stroke-width: 2px;
        fill: black; */
      }

      .score {
        margin-top: 100px;
        margin-left: 50px;
        border: 1px solid black;
        width: 5em;
      }

      .score--value {
        display: inline-block;
        /* transform-origin: left center; */
      }
    </style>
  </head>

  <body>
    <h1>Score animation</h1>
    <p>
      Cliquer sur le bouton pour afficher une animation qui serq utilisée lorsqu'un élement de ui
      influence le score (un dé par example)
    </p>

    <!-- <svg viewBox="0 0 100 100">
      <text
        x="50"
        y="50"
        text-anchor="middle"
        alignment-baseline="middle"
        style="fill: gold; stroke: black; font-size: 48px"
      >
        100
      </text>
    </svg>

    <svg>
      <text
        text-anchor="middle"
        alignment-baseline="middle"
        style="fill: gold; stroke: black; font-size: 48px"
      >
        1000
      </text>
    </svg> -->

    <div id="app"></div>
    <script type="module">
      import React from "react"
      import ReactDOM from "react-dom"
      import { printPointInDocument, getDomNodeRectangle } from "src/dom/dom.position.js"
      import { getRectangleCenterPoint } from "src/helper/rectangle.js"
      import { useSignalEmitter, useSignalListener } from "src/hooks.js"
      import { useAnimateTransitionUsingJs } from "src/animation/useAnimateTransition.js"

      const debug = true

      const App = () => {
        const domNodeRef = React.useRef()
        const totalScoreDomNodeRef = React.useRef()

        const [totalScore, totalScoreSetter] = React.useState(0)
        const [totalScoreWithoutParticles, totalScoreWithoutParticlesSetter] = React.useState(0)
        const [scoreParticles, scoreParticlesSetter] = React.useState([])
        const scoreParticleMergedSignal = useSignalEmitter()

        const [diceKept, diceKeptSetter] = React.useState(false)

        const keepCoin = () => {
          diceKeptSetter(true)
        }
        const unkeepCoin = () => {
          diceKeptSetter(false)
        }

        const mountedRef = React.useRef(false)

        React.useEffect(() => {
          if (!mountedRef.current) {
            mountedRef.current = true
            return () => {}
          }

          if (!diceKept) {
            const to = totalScore - 100
            totalScoreSetter(to)
            totalScoreWithoutParticlesSetter(to)
            return () => {}
          }

          const scoreParticle = {
            id: "coin-bonus-from-dice-1",
            value: 100,
            ...domNodeToScoreParticlePosition(domNodeRef.current),
            onScoreParticleCanceled: () => {},
            onScoreParticleMerged: () => {
              totalScoreWithoutParticlesSetter(to)
              scoreParticlesSetter(
                scoreParticles.filter(
                  (scoreParticleCandidate) => scoreParticleCandidate !== scoreParticle,
                ),
              )
              scoreParticleMergedSignal.emit(scoreParticle)
            },
          }
          const from = totalScore
          const to = totalScore + scoreParticle.value

          totalScoreSetter(to)
          totalScoreWithoutParticlesSetter(from)
          scoreParticlesSetter([...scoreParticles, scoreParticle])

          return () => {
            scoreParticlesSetter(
              scoreParticles.filter(
                (scoreParticleCandidate) => scoreParticleCandidate !== scoreParticle,
              ),
            )
          }
        }, [diceKept])

        return (
          <>
            <div ref={domNodeRef} className="dice"></div>
            <button
              onClick={() => {
                keepCoin()
              }}
            >
              Keep piece
            </button>
            <button
              onClick={() => {
                unkeepCoin()
              }}
            >
              Unkeep piece
            </button>
            <button
              onClick={() => {
                // increaseScore(100)
                // increaseScore(200)
              }}
            >
              +100 piece et +200 combinaison
            </button>
            <button
              onClick={() => {
                // increaseScore(100)
                // increaseScore(200)
                // increaseScore(500)
              }}
            >
              +100 piece et +200 combinaison et + 500 coffre plein
            </button>

            <TotalScore
              value={totalScoreWithoutParticles}
              scoreParticleMergedSignal={scoreParticleMergedSignal}
              totalScoreDomNodeRef={totalScoreDomNodeRef}
            />

            {scoreParticles.map((scoreParticle) => {
              return (
                <ScoreParticle
                  key={scoreParticle.id}
                  totalScoreDomNodeRef={totalScoreDomNodeRef}
                  scoreParticle={scoreParticle}
                />
              )
            })}
          </>
        )
      }

      const TotalScore = ({ value, scoreParticleMergedSignal, totalScoreDomNodeRef }) => {
        const scoreParticleMerged = useSignalListener(scoreParticleMergedSignal)

        React.useEffect(() => {
          if (!scoreParticleMerged) return

          const totalScoreDomNode = totalScoreDomNodeRef.current
          totalScoreDomNode.animate(
            [
              {
                transform: "scale(1.5)",
              },
            ],
            { duration: 300 },
          )
        }, [totalScoreDomNodeRef, scoreParticleMerged])

        const totalScoreAnimatedValue = useAnimateTransitionUsingJs(value, { duration: 600 })

        return (
          <div className="score">
            <p ref={totalScoreDomNodeRef} className="score--value">
              {totalScoreAnimatedValue ? totalScoreAnimatedValue.value : value}
            </p>
          </div>
        )
      }

      const ScoreParticle = ({ totalScoreDomNodeRef, scoreParticle }) => {
        const particleDomNodeRef = React.useRef()
        React.useEffect(() => {
          const particleDomNode = particleDomNodeRef.current
          const totalScoreDomNode = totalScoreDomNodeRef.current
          return animateScoreParticle({
            x: scoreParticle.x,
            y: scoreParticle.y,
            particleDomNode,
            totalScoreDomNode,
            oncancel: scoreParticle.onScoreParticleCanceled,
            onfinish: scoreParticle.onScoreParticleMerged,
          })
        }, [])

        return ReactDOM.createPortal(
          <div ref={particleDomNodeRef} className="score-particle">
            {scoreParticle.value}
          </div>,
          document.body,
        )
      }

      const animateScoreParticle = ({
        x,
        y,
        duration = 800,
        particleDomNode,
        totalScoreDomNode,
        onfinish,
        oncancel,
      }) => {
        const particleDomNodeRectangle = getDomNodeRectangle(particleDomNode)
        const totalScoreDomNodeRectangle = getDomNodeRectangle(totalScoreDomNode)

        const particleWidth = particleDomNodeRectangle.right - particleDomNodeRectangle.left
        const particleHeight = particleDomNodeRectangle.bottom - particleDomNodeRectangle.top
        const startX = x - particleWidth / 2
        const startY = y - particleHeight / 2
        const intermediateX = startX + 5
        const intermediateY = startY - particleHeight * 1.5
        const endX = totalScoreDomNodeRectangle.left
        const endY = totalScoreDomNodeRectangle.top

        particleDomNode.style.left = `${startX}px`
        particleDomNode.style.top = `${startY}px`

        if (debug) {
          printPointInDocument(
            { x: startX, y: startY },
            {
              autoRemove: false,
              color: "yellow",
            },
          )
          printPointInDocument(
            { x: intermediateX, y: intermediateY },
            {
              autoRemove: false,
              color: "orange",
            },
          )
          printPointInDocument(
            { x: endX, y: endY },
            {
              autoRemove: false,
              color: "red",
            },
          )
        }

        // en premier fait apparaitre avec opacité
        const animation = particleDomNode.animate(
          [
            {
              opacity: 0,
              transform: "translate(0px, 0px)",
            },
            {
              offset: 0.1,
              opacity: 1,
              // transform: "translate(0px, 0px)",
            },
            {
              offset: 0.4,
              opacity: 1,
              transform: `translate(${intermediateX - startX}px, ${
                intermediateY - startY
              }px) scale(1.2)`,
            },
            {
              transform: `translate(${endX - startX}px, ${endY - startY}px) scale(1.2)`,
            },
          ],
          {
            duration,
            fill: "forwards",
          },
        )
        animation.onfinish = () => {
          onfinish()
        }

        return () => {
          oncancel()
          animation.cancel()
        }
      }

      const domNodeToScoreParticlePosition = (domNode) => {
        const domNodeRectangle = getDomNodeRectangle(domNode)
        const centerPoint = getRectangleCenterPoint(domNodeRectangle)
        return centerPoint
      }

      ReactDOM.render(<App />, document.querySelector("#app"))
    </script>
  </body>
</html>
