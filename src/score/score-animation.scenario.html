<!DOCTYPE html>
<html>
  <head>
    <title>Score animation</title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="icon" href="../../favicon.png" />
    <script type="importmap" src="../../importmap.dev.importmap"></script>
    <style>
      .dice {
        width: 40px;
        height: 40px;
        background: violet;
      }

      .score-particle {
        position: fixed;
        font-family: Arial;
        font-size: 16px;
        color: gold;
        /* stroke: red;
        stroke-width: 2px;
        fill: black; */
      }

      .score {
        margin-top: 100px;
        margin-left: 50px;
        border: 1px solid black;
        width: 5em;
      }

      .score--value {
        display: inline-block;
        /* transform-origin: left center; */
      }
    </style>
  </head>

  <body>
    <h1>Score animation</h1>
    <p>
      Cliquer sur le bouton pour afficher une animation qui serq utilisée lorsqu'un élement de ui
      influence le score (un dé par example)
    </p>

    <!-- <svg viewBox="0 0 100 100">
      <text
        x="50"
        y="50"
        text-anchor="middle"
        alignment-baseline="middle"
        style="fill: gold; stroke: black; font-size: 48px"
      >
        100
      </text>
    </svg>

    <svg>
      <text
        text-anchor="middle"
        alignment-baseline="middle"
        style="fill: gold; stroke: black; font-size: 48px"
      >
        1000
      </text>
    </svg> -->

    <div id="app"></div>
    <script type="module">
      import React from "react"
      import ReactDOM from "react-dom"
      import { printPointInDocument, getDomNodeRectangle } from "src/dom/dom.position.js"
      import { getRectangleCenterPoint } from "src/helper/rectangle.js"
      import { useUpdateEffect, useSignalEmitter, useSignalListener } from "src/hooks.js"
      import { useAnimateTransitionUsingJs } from "src/animation/useAnimateTransition.js"

      const debug = true

      const App = () => {
        const domNodeRef = React.useRef()
        const totalScoreDomNodeRef = React.useRef()

        const [totalScore, totalScoreSetter] = React.useState(0)
        const [totalScoreDisplayed, totalScoreDisplayedSetter] = React.useState(0)
        const [scoreParticles, addScoreParticle, scoreParticleMergedSignal] = useScoreParticles()

        const [diceKept, diceKeptSetter] = React.useState(false)
        const keepCoin = () => {
          diceKeptSetter(true)
        }
        const unkeepCoin = () => {
          diceKeptSetter(false)
        }

        // score displayed is score without taking into account score into particles
        React.useEffect(() => {
          const scoreInParticles = scoreParticles.reduce(
            (previous, particle) => previous + particle.value,
            0,
          )
          const totalScoreWithoutParticles = totalScore - scoreInParticles
          totalScoreDisplayedSetter(totalScoreWithoutParticles)
        }, [totalScore, scoreParticles])

        const diceKeptRef = React.useRef()
        useUpdateEffect(() => {
          const diceKeptPrevious = diceKeptRef.current
          const diceBecomesKept = !diceKeptPrevious && diceKept
          diceKeptRef.current = diceKept

          if (diceBecomesKept) {
            totalScoreSetter((totalScore) => {
              const to = totalScore + 100
              console.log(`dice kept, add 100 to total score -> ${to}`)
              return to
            })
            return
          }

          const diceBecomesUnkept = diceKeptPrevious && !diceKept
          if (diceBecomesUnkept) {
            totalScoreSetter((totalScore) => {
              const to = totalScore - 100
              console.log(`dice unkept, remove 100 from total score -> ${to}`)
              return to
            })
            return
          }
        }, [diceKept, totalScore])
        // spawning particle happens when dice is kept only
        // (it does not care about totalScore)
        React.useEffect(() => {
          if (diceKept) {
            return addScoreParticle({
              id: "coin-bonus-from-dice-1",
              value: 100,
              ...domNodeToScoreParticlePosition(domNodeRef.current),
            })
          }
          return undefined
        }, [diceKept])

        const [groupOfFour, groupOfFourSetter] = React.useState(false)
        const simulateGroupOfFour = () => {
          groupOfFourSetter(true)
        }
        const groupOfFourRef = React.useRef()
        useUpdateEffect(() => {
          const groupOfFourPrevious = groupOfFourRef.current
          const groupOfFourBecomesTrue = !groupOfFourPrevious && groupOfFour
          groupOfFourRef.current = groupOfFour

          if (groupOfFourBecomesTrue) {
            totalScoreSetter((totalScore) => {
              const to = totalScore + 200
              console.log(`group of four found, add 200 to total score -> ${to}`)
              return to
            })
            return
          }

          const groupOfFourBecomesFalse = groupOfFourPrevious && !groupOfFour
          if (groupOfFourBecomesFalse) {
            totalScoreSetter((totalScore) => {
              const to = totalScore - 200
              console.log(`group of four lost, remove 200 from total score -> ${to}`)
              return to
            })
            return
          }
        }, [groupOfFour, totalScore])
        React.useEffect(() => {
          if (groupOfFour) {
            return addScoreParticle({
              id: "group-bonus-from-dice-1",
              value: 200,
              ...domNodeToScoreParticlePosition(domNodeRef.current),
            })
          }
          return undefined
        }, [groupOfFour])

        return (
          <>
            <div ref={domNodeRef} className="dice"></div>
            <button
              onClick={() => {
                keepCoin()
              }}
            >
              Keep piece
            </button>
            <button
              onClick={() => {
                unkeepCoin()
              }}
            >
              Unkeep piece
            </button>
            <button
              onClick={() => {
                keepCoin()
                simulateGroupOfFour()
              }}
            >
              Keep 4eme piece
            </button>
            <button
              onClick={() => {
                // increaseScore(100)
                // increaseScore(200)
                // increaseScore(500)
              }}
            >
              Keep 3eme piece + coffre plein
            </button>

            <TotalScore
              value={totalScoreDisplayed}
              scoreParticleMergedSignal={scoreParticleMergedSignal}
              totalScoreDomNodeRef={totalScoreDomNodeRef}
            />
            {scoreParticles.map((scoreParticle) => {
              return (
                <ScoreParticle
                  key={scoreParticle.id}
                  totalScoreDomNodeRef={totalScoreDomNodeRef}
                  scoreParticle={scoreParticle}
                />
              )
            })}
          </>
        )
      }

      const useScoreParticles = ({ minDelayBetweenParticles = 500 } = {}) => {
        const [scoreParticles, scoreParticlesSetter] = React.useState([])
        const lastParticleEmissionMsRef = React.useRef(null)
        const scoreParticleMergedSignal = useSignalEmitter()

        const addScoreParticleToState = (scoreParticle) => {
          scoreParticlesSetter([...scoreParticles, scoreParticle])
          return () => {
            scoreParticlesSetter(
              scoreParticles.filter(
                (scoreParticleCandidate) => scoreParticleCandidate !== scoreParticle,
              ),
            )
          }
        }

        const addScoreParticle = ({ id, value, x, y }) => {
          const emitParticle = () => {
            lastParticleEmissionMsRef.current = Date.now()
            const scoreParticle = {
              id,
              value,
              x,
              y,
            }
            const removeScoreParticleFromState = addScoreParticleToState(scoreParticle)
            scoreParticle.onScoreParticleMerged = () => {
              removeScoreParticleFromState()
              scoreParticleMergedSignal.emit(scoreParticle)
            }
            return () => {
              removeScoreParticleFromState()
            }
          }

          const lastParticleEmissionMs = lastParticleEmissionMsRef.current
          if (!lastParticleEmissionMs) {
            return emitParticle()
          }

          const nowMs = Date.now()
          const msEllapsedSinceLastParticle = nowMs - lastParticleEmissionMs
          const msToWait = minDelayBetweenParticles - msEllapsedSinceLastParticle
          if (msToWait <= 0) {
            return emitParticle()
          }

          let cancelParticleAnimation = () => {}
          const timeoutId = setTimeout(() => {
            cancelParticleAnimation = emitParticle()
          }, msToWait)
          return () => {
            clearTimeout(timeoutId)
            cancelParticleAnimation()
          }
        }

        return [scoreParticles, addScoreParticle, scoreParticleMergedSignal]
      }

      const TotalScore = ({ value, scoreParticleMergedSignal, totalScoreDomNodeRef }) => {
        const scoreParticleMerged = useSignalListener(scoreParticleMergedSignal)

        React.useEffect(() => {
          if (!scoreParticleMerged) return

          const totalScoreDomNode = totalScoreDomNodeRef.current
          totalScoreDomNode.animate(
            [
              {
                transform: "scale(1.5)",
              },
            ],
            { duration: 300 },
          )
        }, [totalScoreDomNodeRef, scoreParticleMerged])

        const totalScoreAnimatedValue = useAnimateTransitionUsingJs(value, { duration: 600 })

        return (
          <div className="score">
            <p ref={totalScoreDomNodeRef} className="score--value">
              {totalScoreAnimatedValue ? totalScoreAnimatedValue.value : value}
            </p>
          </div>
        )
      }

      const ScoreParticle = ({ totalScoreDomNodeRef, scoreParticle }) => {
        const particleDomNodeRef = React.useRef()
        React.useEffect(() => {
          const particleDomNode = particleDomNodeRef.current
          const totalScoreDomNode = totalScoreDomNodeRef.current
          return animateScoreParticle({
            x: scoreParticle.x,
            y: scoreParticle.y,
            particleDomNode,
            totalScoreDomNode,
            oncancel: scoreParticle.onScoreParticleCanceled,
            onfinish: scoreParticle.onScoreParticleMerged,
          })
        }, [])

        return (
          <div ref={particleDomNodeRef} className="score-particle">
            {scoreParticle.value}
          </div>
        )
      }

      const animateScoreParticle = ({
        x,
        y,
        duration = 800,
        particleDomNode,
        totalScoreDomNode,
        oncancel = () => {},
        onfinish = () => {},
      }) => {
        const particleDomNodeRectangle = getDomNodeRectangle(particleDomNode)
        const totalScoreDomNodeRectangle = getDomNodeRectangle(totalScoreDomNode)

        const particleWidth = particleDomNodeRectangle.right - particleDomNodeRectangle.left
        const particleHeight = particleDomNodeRectangle.bottom - particleDomNodeRectangle.top
        const startX = x - particleWidth / 2
        const startY = y - particleHeight / 2
        const intermediateX = startX + 5
        const intermediateY = startY - particleHeight * 1.5
        const endX = totalScoreDomNodeRectangle.left
        const endY = totalScoreDomNodeRectangle.top

        particleDomNode.style.left = `${startX}px`
        particleDomNode.style.top = `${startY}px`

        if (debug) {
          printPointInDocument(
            { x: startX, y: startY },
            {
              autoRemove: false,
              color: "yellow",
            },
          )
          printPointInDocument(
            { x: intermediateX, y: intermediateY },
            {
              autoRemove: false,
              color: "orange",
            },
          )
          printPointInDocument(
            { x: endX, y: endY },
            {
              autoRemove: false,
              color: "red",
            },
          )
        }

        // en premier fait apparaitre avec opacité
        const animation = particleDomNode.animate(
          [
            {
              opacity: 0,
              transform: "translate(0px, 0px)",
            },
            {
              offset: 0.1,
              opacity: 1,
              // transform: "translate(0px, 0px)",
            },
            {
              offset: 0.4,
              opacity: 1,
              transform: `translate(${intermediateX - startX}px, ${
                intermediateY - startY
              }px) scale(1.2)`,
            },
            {
              transform: `translate(${endX - startX}px, ${endY - startY}px) scale(1.2)`,
            },
          ],
          {
            duration,
            fill: "forwards",
          },
        )
        animation.onfinish = () => {
          onfinish()
        }

        return () => {
          oncancel()
          animation.cancel()
        }
      }

      const domNodeToScoreParticlePosition = (domNode) => {
        const domNodeRectangle = getDomNodeRectangle(domNode)
        const centerPoint = getRectangleCenterPoint(domNodeRectangle)
        return centerPoint
      }

      ReactDOM.render(<App />, document.querySelector("#app"))
    </script>
  </body>
</html>
