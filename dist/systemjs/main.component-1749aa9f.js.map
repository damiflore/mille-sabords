{
  "version": 3,
  "file": "main.component.js",
  "sources": [
    "../../src/helper/asap.js",
    "../../src/generic/Stylesheet.jsx",
    "../../node_modules/@jsenv/core/helpers/babel/objectWithoutProperties/objectWithoutProperties.js",
    "../../node_modules/@jsenv/core/helpers/babel/objectWithoutPropertiesLoose/objectWithoutPropertiesLoose.js",
    "../../src/dom/dom.util.js",
    "../../src/loading/loading.main.js",
    "../../node_modules/@jsenv/core/helpers/babel/createClass/createClass.js",
    "../../node_modules/@jsenv/core/helpers/babel/setPrototypeOf/setPrototypeOf.js",
    "../../node_modules/@jsenv/core/helpers/babel/getPrototypeOf/getPrototypeOf.js",
    "../../node_modules/@jsenv/core/helpers/babel/possibleConstructorReturn/possibleConstructorReturn.js",
    "../../node_modules/@jsenv/core/helpers/babel/assertThisInitialized/assertThisInitialized.js",
    "../../node_modules/@jsenv/core/helpers/babel/createSuper/createSuper.js",
    "../../node_modules/@jsenv/core/helpers/babel/isNativeReflectConstruct/isNativeReflectConstruct.js",
    "../../src/error/error.main.js",
    "../../src/loading/loading.hooks.js",
    "../../node_modules/@jsenv/pwa/src/internal/listenEvent.js",
    "../../node_modules/@jsenv/pwa/src/navigatorController.js",
    "../../node_modules/@jsenv/pwa/src/internal/createSignal.js",
    "../../node_modules/@jsenv/pwa/src/internal/sendMessageUsingChannel.js",
    "../../src/loading/loadImage.js",
    "../../src/loading/preloadImages.js",
    "../../src/loading/Preloader.jsx",
    "../../node_modules/@jsenv/core/helpers/babel/extends/extends.js",
    "../../src/loading/useImage.js",
    "../../src/hooks.js",
    "../../src/generic/Image.jsx",
    "../../src/generic/useIntersecting.js",
    "../../src/main.component.js",
    "../../node_modules/@jsenv/core/helpers/babel/inherits/inherits.js",
    "../../node_modules/@jsenv/core/helpers/babel/classCallCheck/classCallCheck.js"
  ],
  "sourcesContent": [
    "export const requestAsapCallback = window.requestIdleCallback\n  ? (callback) => {\n      const requestId = window.requestIdleCallback(callback, { timeout: 400 })\n      return () => {\n        window.cancelIdleCallback(requestId)\n      }\n    }\n  : (callback) => {\n      const requestId = window.requestAnimationFrame(callback)\n      return () => {\n        window.cancelAnimationFrame(requestId)\n      }\n    }\n",
    "/**\n\nThis component (Stylesheet) must ensure a given url is loaded as css by the browser.\nTo achieve that it creates a <link> and append it to document.head\n\nIt is important that even if many Stylesheet are instantiated for a given url only\none <link> ends up in the document.head. (Appended it multiple times is useless).\nIt happens for Dialog.base.css for instance.\n\nI have tried to achieve this with ReactDOM.createPortal but could not manage\nto have only one <link> injected.\n\n*/\n\nimport React from \"react\"\nimport { addLoadedListener, useUrlLoadingNotifier } from \"src/loading/loading.main.js\"\n\nexport const Stylesheet = ({ href }) => {\n  const [fetchStart, fetchEnd] = useUrlLoadingNotifier(href)\n\n  React.useEffect(() => {\n    fetchStart()\n    return injectStylesheetIntoDocument(href, {\n      onload: fetchEnd,\n    })\n  }, [href])\n\n  return null\n}\n\nconst memoizeLinksByHref = (fn) => {\n  const linkMap = new Map()\n\n  const stopUsing = (href) => {\n    if (!linkMap.has(href)) {\n      return\n    }\n\n    const { useCount, ...rest } = linkMap.get(href)\n    if (useCount > 1) {\n      linkMap.set(href, {\n        useCount: useCount - 1,\n        ...rest,\n      })\n      return\n    }\n\n    linkMap.delete(href)\n    rest.linkCleanup()\n  }\n\n  return (href, ...args) => {\n    if (linkMap.has(href)) {\n      const { useCount, ...rest } = linkMap.get(href)\n      linkMap.set(href, {\n        useCount: useCount + 1,\n        ...rest,\n      })\n      return stopUsing\n    }\n\n    const linkCleanup = fn(href, ...args)\n    linkMap.set(href, {\n      useCount: 1,\n      linkCleanup,\n    })\n    return stopUsing\n  }\n}\n\nconst injectStylesheetIntoDocument = memoizeLinksByHref((href, { onload = () => {} } = {}) => {\n  const link = document.createElement(\"link\")\n  link.rel = \"stylesheet\"\n  link.type = \"text/css\"\n  const removeLoadedListener = addLoadedListener(link, onload)\n  link.href = href\n  document.head.appendChild(link)\n  return () => {\n    removeLoadedListener()\n    document.head.removeChild(link)\n  }\n})\n",
    "import objectWithoutPropertiesLoose from \"../objectWithoutPropertiesLoose/objectWithoutPropertiesLoose.js\"\n\nexport default (source, excluded) => {\n  if (source === null) return {}\n\n  var target = objectWithoutPropertiesLoose(source, excluded)\n  var key\n  var i\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source)\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i]\n      if (excluded.indexOf(key) >= 0) continue\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue\n      target[key] = source[key]\n    }\n  }\n  return target\n}\n",
    "export default (source, excluded) => {\n  if (source === null) return {}\n  var target = {}\n  var sourceKeys = Object.keys(source)\n  var key\n  var i\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i]\n    if (excluded.indexOf(key) >= 0) continue\n    target[key] = source[key]\n  }\n  return target\n}\n",
    "/* eslint-disable valid-jsdoc */\n\nexport const addDomEventListener = (domNode, eventName, callback, options) => {\n  domNode.addEventListener(eventName, callback, options)\n  return () => {\n    domNode.removeEventListener(eventName, callback, options)\n  }\n}\n\n// checking if somthing is window is tricky\n// we could also use a.constructor.name === 'Window'\n// but it's safer to use approach below\nexport const elementIsWindow = (a) => a.window === a\n\nexport const elementIsDocument = (a) => a.nodeType === 9\n\nexport const elementIsIframe = ({ nodeName }) => nodeName === \"IFRAME\"\n\nexport const isFocusable = (node) => {\n  // only element node can be focused, document, textNodes etc cannot\n  if (node.nodeType !== 1) {\n    return false\n  }\n  const nodeName = node.nodeName.toLowerCase()\n\n  if (nodeName === \"input\") {\n    if (node.type === \"hidden\") {\n      return false\n    }\n    return isVisible(node)\n  }\n\n  if ([\"button\", \"select\", \"datalist\", \"iframe\", \"textarea\"].indexOf(nodeName) > -1) {\n    return isVisible(node)\n  }\n\n  if (node.hasAttribute(\"tabindex\") || node.hasAttribute(\"tabIndex\")) {\n    return isVisible(node)\n  }\n\n  if (node.hasAttribute(\"draggable\")) {\n    return isVisible(node)\n  }\n\n  if ([\"a\", \"area\"].indexOf(nodeName) > -1) {\n    if (node.hasAttribute(\"href\") === false) {\n      return false\n    }\n    return isVisible(node)\n  }\n\n  if ([\"audio\", \"video\"].indexOf(nodeName) > -1) {\n    if (node.hasAttribute(\"controls\") === false) {\n      return false\n    }\n    return isVisible(node)\n  }\n\n  return false\n}\n\nexport const isVisible = (node) => {\n  if (isDocumentElement(node)) {\n    return true\n  }\n  if (getStyleValue(node, \"visibility\") === \"hidden\") {\n    return false\n  }\n\n  let nodeOrAncestor = node\n  while (nodeOrAncestor) {\n    if (isDocumentElement(nodeOrAncestor)) {\n      break\n    }\n    if (getStyleValue(nodeOrAncestor, \"display\") === \"none\") {\n      return false\n    }\n    nodeOrAncestor = nodeOrAncestor.parentNode\n  }\n\n  return true\n}\n\n// https://github.com/davidtheclark/tabbable/blob/master/index.js\nexport const isDocumentElement = (node) => node === node.ownerDocument.documentElement\n\nexport const getStyle = (element) => elementToOwnerWindow(element).getComputedStyle(element)\n\nexport const getStyleValue = (element, name) => getStyle(element).getPropertyValue(name)\n\n/**\n * elementToOwnerWindow returns the window owning the element.\n * Usually an element window will just be window.\n * But when an element is inside an iframe, the window of that element\n * is iframe.contentWindow\n * It's often important to work with the correct window because\n * element are scoped per iframes.\n */\nexport const elementToOwnerWindow = (element) => {\n  if (elementIsWindow(element)) return element\n\n  if (elementIsDocument(element)) return element.defaultView\n\n  return elementToOwnerDocument(element).defaultView\n}\n\n/**\n * elementToOwnerDocument returns the document containing the element.\n * Usually an element document is window.document.\n * But when an element is inside an iframe, the document of that element\n * is iframe.contentWindow.document\n * It's often important to work with the correct document because\n * element are scoped per iframes.\n */\nexport const elementToOwnerDocument = (element) => {\n  if (elementIsWindow(element)) return element.document\n\n  if (elementIsDocument(element)) return element\n\n  return element.ownerDocument\n}\n\nexport const getDocumentScroll = (element) => {\n  const elementWindow = elementToOwnerWindow(element)\n  const elementDocument = elementToOwnerDocument(element)\n  return {\n    x: elementWindow.pageXOffset || elementDocument.documentElement.scrollLeft,\n    y: elementWindow.pageYOffset || elementDocument.documentElement.scrollTop,\n  }\n}\n\n/**\n * elementToOwnerIframe returns the iframe owning the element or null\n * when element is not inside an iframe.\n */\nexport const elementToOwnerIframe = (element) => {\n  const elementOwnerWindow = elementToOwnerWindow(element)\n  // element is not inside an iframe because it is owned by window\n  // if element is window itself, elementOwnerWindow is window too\n  // because elementToOwnerWindow(window) returns window\n  if (elementOwnerWindow === window) return null\n\n  const parentDocument = elementOwnerWindow.parent.document\n  return Array.from(parentDocument.querySelectorAll(\"iframe\")).find(\n    (iframe) => iframeIsFriendly(iframe) && iframe.contentWindow.document.contains(element),\n  )\n}\n\n/**\n * This function is used to ensure we are allowed to manipulate an iframe.\n * If we don't do this check before doing stuff like adding 'mousemove' event\n * to the iframe, it will throw an error.\n * A friendly iframe is usually an iframe with src set to 'about:blank'.\n * The opposite of a friendly iframe is an iframe on an other domain.\n */\nexport const iframeIsFriendly = (iframe) => {\n  const key = `${Number(new Date())}${Math.random()}`\n  const value = {}\n\n  try {\n    const iframeWindow = iframe.contentWindow\n    iframeWindow[key] = value\n    const isFriendly = iframeWindow[key] === value\n    delete iframeWindow[key]\n    return isFriendly\n  } catch (e) {\n    return false\n  }\n}\n",
    "import React from \"react\"\nimport { addDomEventListener } from \"src/dom/dom.util.js\"\n\nconst UrlLoadingContext = React.createContext()\nconst reducer = (state, action) => action(state)\nconst initialState = {}\n\nconst logs = false\n\nexport const UrlLoadingProvider = ({ children }) => {\n  return (\n    <UrlLoadingContext.Provider value={React.useReducer(reducer, initialState)}>\n      {children}\n    </UrlLoadingContext.Provider>\n  )\n}\n\nexport const useUrlTrackerTotalCount = () => {\n  const urlLoadingState = useUrlLoadingState()\n  const totalCount = Object.keys(urlLoadingState).length\n  return totalCount\n}\n\nexport const useUrlTrackerLoadedCount = () => {\n  const urlLoadingState = useUrlLoadingState()\n  const loadedCount = Object.keys(urlLoadingState).filter(\n    (url) => urlLoadingState[url].status === \"loaded\",\n  ).length\n  return loadedCount\n}\n\nexport const useUrlTrackerAllLoaded = () => {\n  const totalCount = useUrlTrackerTotalCount()\n  const loadedCount = useUrlTrackerLoadedCount()\n  return loadedCount === totalCount\n}\n\nexport const useUrlLoadingNotifier = (url) => {\n  url = String(url)\n\n  const contextValue = React.useContext(UrlLoadingContext)\n  const dispatch = contextValue ? contextValue[1] : undefined\n\n  React.useEffect(() => {\n    if (dispatch) {\n      return fetchAbort\n    }\n    return null\n  }, [])\n\n  const fetchStart = () => {\n    dispatch((state) => {\n      if (url in state) {\n        if (logs) {\n          // console.log(\"start loading early return\", url, state[url])\n        }\n        return state\n      }\n      if (logs) {\n        console.log(\"start loading\", url)\n      }\n      return {\n        ...state,\n        [url]: { status: \"loading\" },\n      }\n    })\n  }\n\n  const fetchAbort = () => {\n    dispatch((state) => {\n      if (!state.hasOwnProperty(url)) {\n        return state\n      }\n\n      const status = state[url].status\n      if (status !== \"loading\") {\n        return state\n      }\n\n      if (logs) {\n        console.log(\"abort loading\", url)\n      }\n      const stateWithoutUrl = {}\n      Object.keys(state).forEach((key) => {\n        if (key !== url) {\n          stateWithoutUrl[key] = state[key]\n        }\n      })\n\n      return stateWithoutUrl\n    })\n  }\n\n  const fetchEnd = () => {\n    dispatch((state) => {\n      if (url in state && state[url].status === \"loaded\") {\n        // console.log(\"end loading early return\", url, state[url])\n        return state\n      }\n      if (logs) {\n        console.log(\"end loading\", url)\n      }\n      return {\n        ...state,\n        [url]: { status: \"loaded\" },\n      }\n    })\n  }\n\n  if (!contextValue) {\n    // if (import.meta.dev) {\n    //   console.warn(`useUrlLoadingNotifier was called on a component without UrlLoadingContext`)\n    // }\n    return [() => {}, () => {}, () => {}]\n  }\n\n  return [fetchStart, fetchEnd, fetchAbort]\n}\n\nexport const useDOMNodeLoadingNotifier = (url) => {\n  const [, domNodeFetchEnd] = useUrlLoadingNotifier(url)\n\n  const nodeRefCallback = React.useCallback(\n    (node) => {\n      if (node) {\n        return addLoadedListener(node, domNodeFetchEnd)\n      }\n      return undefined\n    },\n    [domNodeFetchEnd],\n  )\n\n  return nodeRefCallback\n}\n\nconst useUrlLoadingState = () => {\n  const contextValue = React.useContext(UrlLoadingContext)\n  if (!contextValue) {\n    // if (import.meta.dev) {\n    //   console.warn(`useUrlLoadingState was called on a component without UrlLoadingContext`)\n    // }\n    return null\n  }\n  return contextValue[0]\n}\n\nexport const useSingleUrlLoadingTracker = (url) => useUrlLoadingState()[url]\n\nexport const addLoadedListener = (domNode, callback) => {\n  const removeLoadListener = addDomEventListener(domNode, \"load\", () => {\n    removeErrorListener()\n    callback()\n  })\n  const removeErrorListener = addDomEventListener(domNode, \"error\", () => {\n    removeLoadListener()\n    callback()\n  })\n\n  return () => {\n    removeLoadListener()\n    removeErrorListener()\n  }\n}\n",
    "export default (Constructor, protoProps, staticProps) => {\n  if (protoProps) defineProperties(Constructor.prototype, protoProps)\n  if (staticProps) defineProperties(Constructor, staticProps)\n  return Constructor\n}\n\nfunction defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i]\n    descriptor.enumerable = descriptor.enumerable || false\n    descriptor.configurable = true\n    if (\"value\" in descriptor) descriptor.writable = true\n    Object.defineProperty(target, descriptor.key, descriptor)\n  }\n}\n",
    "export default Object.setPrototypeOf ||\n  ((o, p) => {\n    // eslint-disable-next-line no-proto\n    o.__proto__ = p\n    return o\n  })\n",
    "export default Object.setPrototypeOf\n  ? Object.getPrototypeOf\n  : // eslint-disable-next-line no-proto\n    (o) => o.__proto__ || Object.getPrototypeOf(o)\n",
    "import assertThisInitialized from \"../assertThisInitialized/assertThisInitialized.js\"\n\nexport default (self, call) => {\n  if (call && (typeof call === \"object\" || typeof call === \"function\")) {\n    return call\n  }\n  return assertThisInitialized(self)\n}\n",
    "export default (self) => {\n  // eslint-disable-next-line no-void\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\")\n  }\n  return self\n}\n",
    "import getPrototypeOf from \"../getPrototypeOf/getPrototypeOf.js\"\nimport isNativeReflectConstruct from \"../isNativeReflectConstruct/isNativeReflectConstruct.js\"\nimport possibleConstructorReturn from \"../possibleConstructorReturn/possibleConstructorReturn.js\"\n\nexport default function _createSuper(Derived) {\n  var hasNativeReflectConstruct = isNativeReflectConstruct()\n\n  return function _createSuperInternal() {\n    var Super = getPrototypeOf(Derived)\n    var result\n    if (hasNativeReflectConstruct) {\n      // NOTE: This doesn't work if this.__proto__.constructor has been modified.\n      var NewTarget = getPrototypeOf(this).constructor\n      // eslint-disable-next-line prefer-rest-params\n      result = Reflect.construct(Super, arguments, NewTarget)\n    } else {\n      // eslint-disable-next-line prefer-rest-params\n      result = Super.apply(this, arguments)\n    }\n    return possibleConstructorReturn(this, result)\n  }\n}\n",
    "export default function isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false\n  // core-js@3\n  if (Reflect.construct.sham) return false\n  // Proxy can't be polyfilled. Every browser implemented\n  // proxies before or at the same time as Reflect.construct,\n  // so if they support Proxy they also support Reflect.construct.\n  if (typeof Proxy === \"function\") return true\n  // Since Reflect.construct can't be properly polyfilled, some\n  // implementations (e.g. core-js@2) don't set the correct internal slots.\n  // Those polyfills don't allow us to subclass built-ins, so we need to\n  // use our fallback implementation.\n  try {\n    // If the internal slots aren't set, this throws an error similar to\n    // TypeError: this is not a Boolean object.\n    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}))\n    return true\n  } catch (e) {\n    return false\n  }\n}\n",
    "import React from \"react\"\n\nexport const catchError = (LowerLevelComponent, ComponentDisplayedOnError) => {\n  class ErrorBoundary extends React.Component {\n    constructor(props) {\n      super(props)\n      this.state = {\n        hasError: false,\n        error: null,\n      }\n    }\n\n    static getDerivedStateFromError(error) {\n      return {\n        hasError: true,\n        error,\n      }\n    }\n\n    render() {\n      if (this.state.hasError) {\n        return <ComponentDisplayedOnError error={this.state.error} />\n      }\n      return <LowerLevelComponent {...this.props} />\n    }\n  }\n\n  return ErrorBoundary\n}\n",
    "import React from \"react\"\nimport { requestAsapCallback } from \"src/helper/asap.js\"\n\nexport const useWaitABit = () => {\n  const [waited, waitedSetter] = React.useState(false)\n  React.useEffect(() => {\n    return requestAsapCallback(() => {\n      waitedSetter(true)\n    })\n  }, [])\n  return waited\n}\n",
    "export const listenEvent = (objectWithEventEmitter, event, callback) => {\n  objectWithEventEmitter.addEventListener(event, callback)\n  return () => {\n    objectWithEventEmitter.removeEventListener(event, callback)\n  }\n}\n",
    "// do not forget error handling: https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorkerContainer/onerror\n\nimport { createSignal } from \"./internal/createSignal.js\"\nimport { listenEvent } from \"./internal/listenEvent.js\"\nimport { sendMessageUsingChannel } from \"./internal/sendMessageUsingChannel.js\"\n\nconst serviceWorkerAPI = window.navigator.serviceWorker\n\nexport const canUseServiceWorker =\n  Boolean(serviceWorkerAPI) && document.location.protocol === \"https:\"\n\n// https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorkerRegistration\nlet registrationPromise = null\nlet serviceWorker = null\nconst serviceWorkerSetter = (worker) => {\n  serviceWorker = worker\n}\n\nlet serviceWorkerUpdating = null\nconst serviceWorkerUpdatingChangeSignal = createSignal()\nconst serviceWorkerUpdatingSetter = (worker) => {\n  if (serviceWorkerUpdating && serviceWorkerUpdating === worker) {\n    // we already know about this worker, no need to listen state changes.\n    // it happens for manual updates where we bot detect it\n    // from registration.update() return value\n    // and \"updatefound\" event\n    console.log(\"we already know this worker is updating\")\n    return\n  }\n  if (worker) {\n    console.log(`found a worker updating (worker state is: ${worker.state})`)\n  } else {\n    console.log(`worker update is done`)\n  }\n  serviceWorkerUpdating = worker\n  serviceWorkerUpdatingChangeSignal.emit()\n}\n\nexport const serviceWorkerIsAvailable = () => Boolean(registrationPromise)\n\nexport const registerServiceWorker = (url, { scope } = {}) => {\n  if (!canUseServiceWorker) {\n    return () => {}\n  }\n\n  let unregistered = false\n  let unregister = () => {}\n  let removeUpdateFoundListener = () => {}\n\n  registrationPromise = serviceWorkerAPI.register(url, { scope })\n  ;(async () => {\n    const registration = await registrationPromise\n    unregister = () => {\n      registration.unregister()\n    }\n\n    if (unregistered) {\n      unregister()\n      return\n    }\n\n    const { installing, waiting, active } = registration\n    serviceWorkerSetter(installing || waiting || active)\n    removeUpdateFoundListener = listenEvent(registration, \"updatefound\", () => {\n      console.log(\"browser notifies use an worker is installing\")\n      if (registration.installing === installing) {\n        console.log(`it's not an worker update, it's first time worker registers`)\n        return\n      }\n      serviceWorkerUpdatingSetter(registration.installing)\n    })\n  })()\n\n  return () => {\n    unregistered = true\n    removeUpdateFoundListener()\n    unregister()\n  }\n}\n\n// export const getServiceWorkerState = () => {\n//   if (serviceWorker) {\n//     return serviceWorker.state\n//   }\n//   return null\n// }\n\n// export const listenServiceWorkerState = (callback) => {\n//   let removeStateChangeListener = () => {}\n//   const removeWorkerChangeListener = serviceWorkerChangeSignal.listen(() => {\n//     callback()\n//     removeStateChangeListener = listenEvent(serviceWorker, \"statechange\", callback)\n//   })\n//   return () => {\n//     removeWorkerChangeListener()\n//     removeStateChangeListener()\n//   }\n// }\n\n// For now this function will try to communicate with the old service worker\n// even if new worker is activating or activated.\n// It might not work because, from what I understood, the old worker gets killed\n// by the navigator as soon as the new worker starts to activate.\n// Maybe it should communicate with the new worker as soon as we know\n// updating worker is activating or activated.\n// -> yes\nexport const sendMessageToServiceWorker = (message) => {\n  if (!serviceWorker) {\n    console.warn(`no service worker to send message to`)\n    return undefined\n  }\n  return sendMessageUsingChannel(serviceWorker, message)\n}\n\nexport const getServiceWorkerUpdate = () => {\n  return serviceWorkerUpdating\n    ? {\n        shouldBecomeNavigatorController: Boolean(serviceWorkerAPI.controller),\n        navigatorWillReload: autoReloadEnabled,\n      }\n    : null\n}\n\nexport const listenServiceWorkerUpdate = (callback) => {\n  return serviceWorkerUpdatingChangeSignal.listen(callback)\n}\n\nexport const checkServiceWorkerUpdate = async () => {\n  if (!registrationPromise) {\n    console.warn(`registerServiceWorker must be called before checkServiceWorkerUpdate can be used`)\n    return false\n  }\n\n  const registration = await registrationPromise\n  // await for the registration promise above can take some time\n  // especially when the service worker is installing for the first time\n  // because it is fetching a lot of urls to put into cache.\n  // In that scenario we might want to display something different ?\n  // Without this UI seems to take ages to check for an update\n  const updateRegistration = await registration.update()\n\n  const { installing } = updateRegistration\n  if (installing) {\n    console.log(\"installing worker found after calling update()\")\n    serviceWorkerUpdatingSetter(installing)\n    return true\n  }\n\n  const { waiting } = updateRegistration\n  if (waiting) {\n    console.log(\"waiting worker found after calling update()\")\n    serviceWorkerUpdatingSetter(waiting)\n    return true\n  }\n\n  console.log(\"no worker found after calling update()\")\n  return false\n}\n\nexport const sendMessageToServiceWorkerUpdate = (message) => {\n  if (!serviceWorkerUpdating) {\n    console.warn(`no service worker updating to send message to`)\n    return undefined\n  }\n  return sendMessageUsingChannel(serviceWorkerUpdating, message)\n}\n\nexport const activateServiceWorkerUpdate = async (params) => {\n  if (!serviceWorkerUpdating) {\n    throw new Error(\"no service worker update to activate\")\n  }\n  return sendSkipWaitingToWorker(serviceWorkerUpdating, params)\n}\n\nconst sendSkipWaitingToWorker = async (\n  worker,\n  { onActivating = () => {}, onActivated = () => {}, onBecomesNavigatorController = () => {} } = {},\n) => {\n  const { state } = worker\n  const waitUntilActivated = () => {\n    return new Promise((resolve) => {\n      const removeStateChangeListener = listenEvent(worker, \"statechange\", () => {\n        if (worker.state === \"activating\") {\n          serviceWorkerSetter(serviceWorkerUpdating)\n          onActivating()\n        }\n        if (worker.state === \"activated\") {\n          serviceWorkerSetter(serviceWorkerUpdating)\n          onActivated()\n          removeStateChangeListener()\n          resolve()\n        }\n      })\n    })\n  }\n\n  // worker must be waiting (meaning state must be \"installed\")\n  // to be able to call skipWaiting on it.\n  // If it's installing it's an error.\n  // If it's activating, we'll just skip the skipWaiting call\n  // If it's activated, we'll just return early\n  if (state === \"installed\" || state === \"activating\") {\n    if (state === \"installed\") {\n      sendMessageToServiceWorkerUpdate({ action: \"skipWaiting\" })\n    }\n    if (state === \"activating\") {\n      serviceWorkerSetter(serviceWorkerUpdating)\n    }\n    await waitUntilActivated()\n\n    if (serviceWorkerAPI.controller) {\n      const removeControllerChangeListener = listenEvent(\n        serviceWorkerAPI,\n        \"controllerchange\",\n        () => {\n          removeControllerChangeListener()\n          onBecomesNavigatorController()\n          serviceWorkerUpdatingSetter(null)\n          if (autoReloadEnabled) reload()\n        },\n      )\n    } else {\n      serviceWorkerUpdatingSetter(null)\n      if (autoReloadEnabled) reload()\n    }\n    return\n  }\n\n  serviceWorkerSetter(serviceWorkerUpdating)\n  onBecomesNavigatorController()\n  serviceWorkerUpdatingSetter(null)\n  if (autoReloadEnabled) reload()\n}\n\nlet autoReloadEnabled = true\nlet disableAutoReload = () => {}\nexport const autoReloadAfterUpdateIsEnabled = () => autoReloadEnabled\nexport const disableAutoReloadAfterUpdate = () => disableAutoReload()\n\nlet refreshing = false\nconst reload = () => {\n  if (refreshing) {\n    return\n  }\n  refreshing = true\n  window.location.reload()\n}\n\nif (canUseServiceWorker) {\n  const removeControllerChangeListener = listenEvent(serviceWorkerAPI, \"controllerchange\", reload)\n\n  disableAutoReload = () => {\n    autoReloadEnabled = false\n    removeControllerChangeListener()\n  }\n}\n\n// const navigatorIsControlledByAServiceWorker = () => {\n//   return canUseServiceWorker ? Boolean(serviceWorkerAPI.controller) : false\n// }\n\n// const getServiceWorkerControllingNavigator = () => {\n//   return navigatorIsControlledByAServiceWorker() ? serviceWorkerAPI.controller : null\n// }\n",
    "export const createSignal = () => {\n  let listeners = []\n\n  const listen = (callback, { once = false } = {}) => {\n    if (once) {\n      const callbackOriginal = callback\n      callback = (...args) => {\n        stopListening()\n        callbackOriginal(...args)\n      }\n    }\n\n    listeners = [...listeners, callback]\n\n    let removed = false\n    const stopListening = () => {\n      if (removed) return\n      removed = true\n      const listenersWithoutCallback = []\n      let i = listeners.length\n      let searching = true\n      while (i--) {\n        const listenerCandidate = listeners[i]\n        if (searching) {\n          if (listenerCandidate === callback) {\n            searching = false\n          } else {\n            listenersWithoutCallback.push(listenerCandidate)\n          }\n        } else {\n          listenersWithoutCallback.push(listenerCandidate)\n        }\n      }\n      listeners = listenersWithoutCallback\n    }\n    return stopListening\n  }\n\n  const emit = (...args) => {\n    listeners.forEach((listener) => {\n      listener(...args)\n    })\n  }\n\n  return {\n    listen,\n    emit,\n  }\n}\n",
    "// https://felixgerschau.com/how-to-communicate-with-service-workers/\nexport const sendMessageUsingChannel = (objectWithPostMessage, message) => {\n  const { port1, port2 } = new MessageChannel()\n  return new Promise((resolve, reject) => {\n    port1.onmessage = function (event) {\n      if (event.data.status === \"rejected\") {\n        reject(event.data.value)\n      } else {\n        resolve(event.data.value)\n      }\n    }\n    objectWithPostMessage.postMessage(message, [port2])\n  })\n}\n",
    "// https://vincenttaverna.com/posts/react-image-hook/\nexport const loadImage = (url, crossOrigin) => {\n  const image = new Image()\n\n  if (crossOrigin) {\n    image.crossOrigin = crossOrigin\n  }\n\n  return new Promise((resolve, reject) => {\n    // Load Handler\n    const loaded = (event) => {\n      // Cleanup our image element, we no longer need it\n      unbindEvents(image)\n      // Fulfill our promise with the event image element, even in older browsers\n      resolve(event.target || event.srcElement)\n    }\n\n    // Error Handler\n    const errored = (error) => {\n      // Cleanup our image element, we no longer need it\n      unbindEvents(image)\n      // Forward our error to the user\n      reject(error)\n    }\n\n    // Set our handlers\n    image.onload = loaded\n    image.onerror = errored\n    image.onabort = errored\n\n    // Tell the browser we are ready to begin downloading\n    image.src = url\n  })\n}\n\nconst unbindEvents = (image) => {\n  // Reset callbacks\n  image.onload = null\n  image.onerror = null\n  image.onabort = null\n\n  try {\n    // Some browsers need you to remove the src\n    // in order to garbage collect the image object\n    delete image.src\n  } catch (e) {\n    // Safari's strict mode throws, ignore\n  }\n}\n",
    "import { loadImage } from \"./loadImage.js\"\n\nexport const preloadImages = async (\n  images,\n  { chunkSize = 7, msDelayBetweenChunks = 2000 } = {},\n) => {\n  let index = 0\n  const loaded = {}\n  const failed = {}\n\n  const preloadChunk = async (chunk) => {\n    await Promise.all(\n      chunk.map(async (src) => {\n        try {\n          const image = await loadImage(src)\n          loaded[src] = image\n        } catch (error) {\n          failed[src] = true\n        }\n      }),\n    )\n    await new Promise((resolve) => {\n      setTimeout(resolve, msDelayBetweenChunks)\n    })\n    const nextChunk = getNextChunk()\n    if (nextChunk.length > 0) {\n      await preloadChunk(nextChunk)\n    }\n  }\n\n  const getNextChunk = () => {\n    const chunk = []\n    let i = 0\n    while (i < chunkSize && index < images.length) {\n      chunk.push(images[index])\n      i++\n      index++\n    }\n    return chunk\n  }\n\n  await preloadChunk(getNextChunk())\n\n  return { loaded, failed }\n}\n",
    "/* eslint-disable import/max-dependencies */\nimport React from \"react\"\nimport { registerServiceWorker } from \"@jsenv/pwa\"\n\nimport { cardDefaultUrl, cardImageUrlMap } from \"src/cards/cards.js\"\nimport { preloadImages } from \"src/loading/preloadImages.js\"\nimport { useWaitABit } from \"./loading.hooks.js\"\n\nconst woodUrl = new URL(\"/src/wood.jpg\", import.meta.url)\nconst pirateHookUrl = new URL(\"/src/chest/pirate-hook.png\", import.meta.url)\nconst pirateHook2Url = new URL(\"/src/chest/pirate-hook-02.png\", import.meta.url)\nconst woodBoxUrl = new URL(\"/src/chest/wood-box.jpg\", import.meta.url)\nconst treasureMapUrl = new URL(\"/src/dice-ongoing/treasure-map.png\", import.meta.url)\nconst witchLabelUrl = new URL(\"/src/skull-island/witch-label.png\", import.meta.url)\nconst skullBottleUrl = new URL(\"/src/skull-island/skull-bottle.png\", import.meta.url)\n\nexport const Preloader = () => {\n  const waited = useWaitABit()\n\n  React.useEffect(() => {\n    if (waited) {\n      registerServiceWorker(\"/service-worker.js\")\n    }\n  }, [waited])\n\n  return waited ? <ImagePreloader /> : null\n}\n\nconst ImagePreloader = () => {\n  const images = [\n    woodUrl,\n    pirateHookUrl,\n    pirateHook2Url,\n    woodBoxUrl,\n    treasureMapUrl,\n    witchLabelUrl,\n    skullBottleUrl,\n    cardDefaultUrl,\n    ...Object.keys(cardImageUrlMap).map((key) => cardImageUrlMap[key]),\n  ]\n\n  React.useEffect(() => {\n    const timeoutId = setTimeout(() => preloadImages(images), 2000)\n    return () => {\n      clearTimeout(timeoutId)\n    }\n  }, [])\n\n  return null\n}\n",
    "function assign(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    // eslint-disable-next-line prefer-rest-params\n    var source = arguments[i]\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key]\n      }\n    }\n  }\n  return target\n}\n\nexport default Object.assign || assign\n",
    "import React from \"react\"\nimport { loadImage } from \"./loadImage.js\"\n\nconst cache = new Map()\n\nexport const Status = {\n  LOADING: \"loading\",\n  LOADED: \"loaded\",\n  FAILED: \"failed\",\n}\n\nexport const useImage = (src, { lazy = false } = {}) => {\n  const cacheEntry = cache.get(src)\n  const statusInitial = cacheEntry ? Status.LOADED : Status.LOADING\n  const [status, setStatus] = React.useState(statusInitial)\n\n  const mounted = React.useRef(false)\n  React.useEffect(() => {\n    mounted.current = true\n    return () => {\n      mounted.current = false\n    }\n  }, [])\n\n  const startLoading = React.useCallback(async () => {\n    if (status === Status.LOADED) {\n      return\n    }\n\n    try {\n      const image = await loadImage(src)\n\n      if (!mounted.current) {\n        // don't call setState on unmounted component\n        console.log(\"image unmounted\")\n        return\n      }\n      cache.set(src, image)\n      setStatus(Status.LOADED)\n    } catch (error) {\n      if (!mounted.current) {\n        // don't call setState on unmounted component\n        return\n      }\n      cache.delete(src)\n      setStatus(Status.FAILED)\n    }\n  }, [setStatus, src])\n\n  React.useEffect(() => {\n    if (!lazy) {\n      startLoading()\n    }\n  }, [lazy])\n\n  return [status, startLoading]\n}\n",
    "import React from \"react\"\n\nexport const useMountEffect = (effect) => {\n  React.useEffect(effect, [])\n}\n\nexport const useUpdateEffect = (effect, dependencies = [], { layout = false } = {}) => {\n  const isInitialMount = React.useRef(true)\n  ;(layout ? React.useLayoutEffect : React.useEffect)(() => {\n    if (isInitialMount.current) {\n      isInitialMount.current = false\n      return undefined\n    }\n\n    return effect()\n  }, dependencies)\n}\n\n// https://stackoverflow.com/a/61680184/2634179\nexport const useBecomes = (becomesPredicate, deps) => {\n  const transition = useTransition(becomesPredicate, deps)\n  return Boolean(transition)\n}\n\nexport const useTransition = (transitionPredicate, deps) => {\n  const mountedRef = React.useRef(false)\n  React.useEffect(() => {\n    if (mountedRef.current === false) {\n      mountedRef.current = true\n    }\n  })\n\n  const depsRef = React.useRef(deps)\n  React.useEffect(() => {\n    depsRef.current = deps\n  }, deps)\n\n  if (!mountedRef.current) {\n    return null\n  }\n  if (!transitionPredicate(...depsRef.current)) {\n    return null\n  }\n  return {\n    from: depsRef.current,\n    to: deps,\n  }\n}\n\nexport const usePrevious = (value) => {\n  const ref = React.useRef(value)\n  React.useEffect(() => {\n    ref.current = value\n  }, [value])\n  return ref.current\n}\n",
    "import React from \"react\"\n\nimport { useUrlLoadingNotifier } from \"src/loading/loading.main.js\"\nimport { useImage } from \"src/loading/useImage.js\"\nimport { usePrevious } from \"../hooks.js\"\nimport { useIntersecting } from \"./useIntersecting.js\"\n\nexport const Image = ({\n  loadWhenIntersecting = true,\n  usePlaceholderWhileLoading = true,\n  animateLoaded = true,\n\n  intersectionRoot,\n  intersectionRootMargin,\n  intersectionThreshold,\n  FallbackWhileNotIntersecting = ImageNotIntersectingFallback,\n  FallbackWhileLoading = ImageLoadingFallback,\n  useImageStatusHook = useImage,\n\n  src,\n  ...props\n}) => {\n  const [status, startLoadingImage] = useImageStatusHook(src, { lazy: loadWhenIntersecting })\n  const statusPrevious = usePrevious(status)\n\n  const [imageFetchStart, imageFetchEnd] = useUrlLoadingNotifier(src)\n  React.useEffect(() => {\n    if (statusPrevious !== \"loading\" && status === \"loading\") {\n      imageFetchStart()\n    }\n    if (statusPrevious !== \"loaded\" && status === \"loaded\") {\n      imageFetchEnd()\n    }\n  }, [statusPrevious, status])\n\n  const [domNodeRefForIntersection, intersecting] = useIntersecting({\n    root: intersectionRoot,\n    rootMargin: intersectionRootMargin,\n    threshold: intersectionThreshold,\n  })\n\n  const intersectingPrevious = usePrevious(intersecting)\n  React.useEffect(() => {\n    // console.log({ src, loadWhenIntersecting, intersectingPrevious, intersecting })\n    if (loadWhenIntersecting && !intersectingPrevious && intersecting) {\n      // console.log(\"start loading\", String(src))\n      startLoadingImage()\n    }\n  }, [loadWhenIntersecting, intersectingPrevious, intersecting])\n\n  const [domNodeRefForAnimation, startAnimation] = useImageLoadAnimation()\n  React.useLayoutEffect(() => {\n    if (animateLoaded && statusPrevious !== \"loaded\" && status === \"loaded\") {\n      startAnimation()\n    }\n  }, [animateLoaded, statusPrevious, status])\n\n  if (loadWhenIntersecting && status !== \"loaded\" && !intersecting) {\n    return <FallbackWhileNotIntersecting ref={domNodeRefForIntersection} />\n  }\n\n  if (usePlaceholderWhileLoading && status !== \"loaded\") {\n    return <FallbackWhileLoading />\n  }\n\n  return <img src={src} ref={domNodeRefForAnimation} {...props} />\n}\n\nconst useImageLoadAnimation = () => {\n  const domNodeRef = React.useRef()\n\n  const startAnimation = React.useCallback(() => {\n    const domNode = domNodeRef.current\n    const opacity = window.getComputedStyle(domNode).getPropertyValue(\"opacity\")\n    domNode.animate([{ opacity: 0 }, { opacity }], {\n      duration: 300,\n    })\n  })\n\n  return [domNodeRef, startAnimation]\n}\n\n// eslint-disable-next-line react/display-name\nconst ImageLoadingFallback = React.forwardRef((props, ref) => {\n  return <img src={TRANSPARENT_PNG_DATA_URL} ref={ref} {...props} />\n})\n\n// eslint-disable-next-line react/display-name\nconst ImageNotIntersectingFallback = React.forwardRef((props, ref) => {\n  return <img src={TRANSPARENT_PNG_DATA_URL} ref={ref} {...props} />\n})\n\nconst TRANSPARENT_PNG_DATA_URL =\n  \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNkYAAAAAYAAjCB0C8AAAAASUVORK5CYII=\"\n",
    "import React from \"react\"\n\nexport const useIntersecting = ({ root, rootMargin, threshold = 0 }) => {\n  const [isIntersecting, isIntersectingSetter] = React.useState(false)\n  const domNodeRef = React.useRef()\n\n  React.useEffect(() => {\n    const domNode = domNodeRef.current\n    if (!domNode) {\n      return null\n    }\n    if (isIntersecting) {\n      return null\n    }\n\n    // https://developer.mozilla.org/fr/docs/Web/API/Intersection_Observer_API\n    const observer = new window.IntersectionObserver(\n      ([entry]) => {\n        if (entry.isIntersecting) {\n          observer.unobserve(domNode)\n          isIntersectingSetter(true)\n        } else {\n          isIntersectingSetter(false)\n        }\n      },\n      {\n        root,\n        rootMargin,\n        threshold,\n      },\n    )\n    observer.observe(domNode)\n\n    return () => {\n      observer.disconnect()\n    }\n  }, [isIntersecting])\n\n  return [domNodeRef, isIntersecting]\n}\n",
    "/* eslint-disable import/max-dependencies */\nimport React from \"react\"\nimport { requestAsapCallback } from \"src/helper/asap.js\"\nimport { Stylesheet } from \"src/generic/Stylesheet.jsx\"\nimport { catchError } from \"src/error/error.main.js\"\nimport {\n  UrlLoadingProvider,\n  useUrlTrackerTotalCount,\n  useUrlTrackerLoadedCount,\n} from \"src/loading/loading.main.js\"\nimport { useWaitABit } from \"src/loading/loading.hooks.js\"\nimport { Preloader } from \"src/loading/Preloader.jsx\"\nimport { symbolSkullUrl } from \"src/symbols/symbols.js\"\nimport { Image } from \"src/generic/Image.jsx\"\n\nconst loadscreenCssUrl = new URL(\"../loadscreen.css\", import.meta.url)\n\nconst MainRaw = (props) => {\n  return (\n    <UrlLoadingProvider>\n      <LoadScreen {...props}></LoadScreen>\n    </UrlLoadingProvider>\n  )\n}\n\nconst LoadScreen = (props) => {\n  const loadscreenRef = React.useRef()\n  const loadscreenUrlTrackerReady = useWaitABit()\n  const [loadscreenUrlsLoaded, loadscreenUrlsLoadedSetter] = React.useState(false)\n\n  // main must wait for loadscreen + request idle callback before starting\n  const [mainImportLoading, mainImportLoadingSetter] = React.useState(false)\n  const [mainImportNamespace, mainImportNamespaceSetter] = React.useState(null)\n  const [mainUrlTrackerReady, mainUrlTrackerReadySetter] = React.useState(false)\n  const [mainUrlsLoaded, mainsUrlsLoadedSetter] = React.useState(false)\n  const [, mainUrlErrorSetter] = React.useState()\n\n  const urlTrackerTotalCount = useUrlTrackerTotalCount()\n  const urlTrackerLoadedCount = useUrlTrackerLoadedCount()\n\n  React.useEffect(() => {\n    if (loadscreenUrlTrackerReady && urlTrackerLoadedCount === urlTrackerTotalCount) {\n      loadscreenUrlsLoadedSetter(true)\n    }\n  }, [loadscreenUrlTrackerReady, urlTrackerLoadedCount, urlTrackerTotalCount])\n\n  React.useEffect(() => {\n    if (!loadscreenUrlsLoaded) {\n      return\n    }\n\n    window.splashscreen.remove()\n\n    mainImportLoadingSetter(true)\n    ;(async () => {\n      try {\n        const namespace = await import(\"./App.jsx\")\n        mainImportLoadingSetter(false)\n        mainImportNamespaceSetter(namespace)\n        requestAsapCallback(() => {\n          mainUrlTrackerReadySetter(true)\n        })\n      } catch (e) {\n        // https://github.com/facebook/react/issues/14981\n        mainUrlErrorSetter(() => {\n          throw e\n        })\n      }\n    })()\n  }, [loadscreenUrlsLoaded])\n\n  React.useEffect(() => {\n    if (mainUrlTrackerReady && urlTrackerLoadedCount === urlTrackerTotalCount) {\n      mainsUrlsLoadedSetter(true)\n    }\n  }, [mainUrlTrackerReady, urlTrackerLoadedCount, urlTrackerTotalCount])\n\n  React.useEffect(() => {\n    if (mainUrlsLoaded && loadscreenRef) {\n      const animation = loadscreenRef.current.animate([{ opacity: 1 }, { opacity: 0 }], {\n        duration: 300,\n        fill: \"forwards\",\n      })\n      animation.onfinish = () => {\n        loadscreenRef.current.style.display = \"none\"\n      }\n    }\n  }, [loadscreenRef, mainUrlsLoaded])\n\n  return (\n    <>\n      {mainImportNamespace ? <mainImportNamespace.App {...props} /> : null}\n      <div id=\"loadscreen\" ref={loadscreenRef}>\n        <Stylesheet href={loadscreenCssUrl} />\n        <Image src={symbolSkullUrl} animateLoaded={false} />\n        {mainImportLoading ? (\n          <p className=\"text\">Chargement du jeu...</p>\n        ) : (\n          <>\n            <p className=\"text\">Chargement du jeu...</p>\n            <div className=\"progress\">\n              {urlTrackerLoadedCount}/{urlTrackerTotalCount}\n            </div>\n          </>\n        )}\n      </div>\n      {mainUrlsLoaded ? <Preloader /> : null}\n    </>\n  )\n}\n\nconst ErrorScreen = ({ error }) => {\n  window.splashscreen.remove()\n  return (\n    <div style={{ maxWidth: \"100vw\" }}>\n      <div style={{ margin: \"10px 15px\" }}>An error occured</div>\n      <pre style={{ overflow: \"auto\", margin: \"10px 15px\" }}>\n        {typeof error === \"object\" ? error.stack : error}\n      </pre>\n    </div>\n  )\n}\n\nexport const Main = catchError(MainRaw, ErrorScreen)\n",
    "import setPrototypeOf from \"../setPrototypeOf/setPrototypeOf.js\"\n\nexport default function _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\")\n  }\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true,\n    },\n  })\n  if (superClass) setPrototypeOf(subClass, superClass)\n}\n",
    "export default function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\")\n  }\n}\n"
  ],
  "names": [
    "fn",
    "linkMap",
    "stopUsing",
    "requestAsapCallback",
    "window",
    "requestIdleCallback",
    "callback",
    "requestId",
    "timeout",
    "cancelIdleCallback",
    "requestAnimationFrame",
    "cancelAnimationFrame",
    "source",
    "excluded",
    "key",
    "i",
    "target",
    "sourceKeys",
    "Object",
    "keys",
    "length",
    "indexOf",
    "objectWithoutPropertiesLoose",
    "getOwnPropertySymbols",
    "sourceSymbolKeys",
    "prototype",
    "propertyIsEnumerable",
    "call",
    "addDomEventListener",
    "domNode",
    "eventName",
    "options",
    "addEventListener",
    "removeEventListener",
    "elementIsWindow",
    "a",
    "elementIsDocument",
    "nodeType",
    "isVisible",
    "node",
    "nodeName",
    "toLowerCase",
    "type",
    "hasAttribute",
    "isDocumentElement",
    "getStyleValue",
    "nodeOrAncestor",
    "parentNode",
    "ownerDocument",
    "documentElement",
    "element",
    "name",
    "elementToOwnerWindow",
    "getComputedStyle",
    "getStyle",
    "getPropertyValue",
    "defaultView",
    "elementToOwnerDocument",
    "document",
    "UrlLoadingContext",
    "elementWindow",
    "elementDocument",
    "x",
    "pageXOffset",
    "scrollLeft",
    "y",
    "pageYOffset",
    "scrollTop",
    "React",
    "createContext",
    "reducer",
    "state",
    "action",
    "initialState",
    "UrlLoadingProvider",
    "children",
    "Provider",
    "value",
    "useReducer",
    "useUrlLoadingNotifier",
    "url",
    "String",
    "contextValue",
    "useContext",
    "dispatch",
    "undefined",
    "useEffect",
    "fetchAbort",
    "hasOwnProperty",
    "status",
    "stateWithoutUrl",
    "forEach",
    "useUrlLoadingState",
    "addLoadedListener",
    "removeLoadListener",
    "removeErrorListener",
    "Stylesheet",
    "href",
    "fetchStart",
    "fetchEnd",
    "injectStylesheetIntoDocument",
    "onload",
    "link",
    "createElement",
    "rel",
    "removeLoadedListener",
    "head",
    "appendChild",
    "removeChild",
    "Map",
    "has",
    "get",
    "useCount",
    "rest",
    "set",
    "delete",
    "linkCleanup",
    "args",
    "defineProperties",
    "props",
    "descriptor",
    "enumerable",
    "configurable",
    "writable",
    "defineProperty",
    "setPrototypeOf",
    "o",
    "p",
    "__proto__",
    "getPrototypeOf",
    "self",
    "_typeof",
    "ReferenceError",
    "assertThisInitialized",
    "_createSuper",
    "Derived",
    "hasNativeReflectConstruct",
    "Reflect",
    "construct",
    "sham",
    "Proxy",
    "Boolean",
    "valueOf",
    "e",
    "isNativeReflectConstruct",
    "result",
    "Super",
    "NewTarget",
    "this",
    "constructor",
    "arguments",
    "apply",
    "possibleConstructorReturn",
    "useWaitABit",
    "useState",
    "waited",
    "waitedSetter",
    "listenEvent",
    "objectWithEventEmitter",
    "event",
    "_await",
    "then",
    "direct",
    "Promise",
    "resolve",
    "serviceWorkerAPI",
    "navigator",
    "serviceWorker",
    "f",
    "reject",
    "body",
    "listeners",
    "canUseServiceWorker",
    "location",
    "protocol",
    "registrationPromise",
    "serviceWorkerUpdating",
    "serviceWorkerUpdatingChangeSignal",
    "listen",
    "once",
    "callbackOriginal",
    "stopListening",
    "removed",
    "listenersWithoutCallback",
    "searching",
    "listenerCandidate",
    "push",
    "emit",
    "listener",
    "serviceWorkerUpdatingSetter",
    "worker",
    "console",
    "log",
    "sendMessageToServiceWorkerUpdate",
    "shouldBecomeNavigatorController",
    "controller",
    "navigatorWillReload",
    "autoReloadEnabled",
    "registration",
    "update",
    "updateRegistration",
    "installing",
    "waiting",
    "warn",
    "message",
    "objectWithPostMessage",
    "MessageChannel",
    "port1",
    "port2",
    "onmessage",
    "data",
    "postMessage",
    "sendMessageUsingChannel",
    "sendSkipWaitingToWorker",
    "params",
    "Error",
    "onActivating",
    "onActivated",
    "onBecomesNavigatorController",
    "waitUntilActivated",
    "removeStateChangeListener",
    "removeControllerChangeListener",
    "reload",
    "refreshing",
    "loadImage",
    "crossOrigin",
    "image",
    "Image",
    "errored",
    "error",
    "unbindEvents",
    "srcElement",
    "onerror",
    "onabort",
    "src",
    "recover",
    "preloadImages",
    "images",
    "chunkSize",
    "msDelayBetweenChunks",
    "index",
    "loaded",
    "failed",
    "preloadChunk",
    "chunk",
    "all",
    "map",
    "setTimeout",
    "nextChunk",
    "getNextChunk",
    "woodUrl",
    "URL",
    "System",
    "import",
    "pirateHookUrl",
    "pirateHook2Url",
    "woodBoxUrl",
    "treasureMapUrl",
    "witchLabelUrl",
    "skullBottleUrl",
    "Preloader",
    "scope",
    "unregistered",
    "unregister",
    "removeUpdateFoundListener",
    "register",
    "active",
    "registerServiceWorker",
    "ImagePreloader",
    "cardDefaultUrl",
    "cardImageUrlMap",
    "timeoutId",
    "clearTimeout",
    "assign",
    "cache",
    "Status",
    "useImage",
    "lazy",
    "cacheEntry",
    "statusInitial",
    "setStatus",
    "mounted",
    "useRef",
    "current",
    "startLoading",
    "useCallback",
    "useTransition",
    "effect",
    "dependencies",
    "layout",
    "isInitialMount",
    "useLayoutEffect",
    "becomesPredicate",
    "deps",
    "transition",
    "transitionPredicate",
    "mountedRef",
    "depsRef",
    "from",
    "to",
    "usePrevious",
    "ref",
    "loadWhenIntersecting",
    "usePlaceholderWhileLoading",
    "animateLoaded",
    "intersectionRoot",
    "intersectionRootMargin",
    "intersectionThreshold",
    "FallbackWhileNotIntersecting",
    "ImageNotIntersectingFallback",
    "FallbackWhileLoading",
    "ImageLoadingFallback",
    "useImageStatusHook",
    "startLoadingImage",
    "statusPrevious",
    "imageFetchStart",
    "imageFetchEnd",
    "root",
    "rootMargin",
    "threshold",
    "isIntersecting",
    "isIntersectingSetter",
    "domNodeRef",
    "observer",
    "IntersectionObserver",
    "unobserve",
    "observe",
    "disconnect",
    "useIntersecting",
    "domNodeRefForIntersection",
    "intersecting",
    "intersectingPrevious",
    "useImageLoadAnimation",
    "domNodeRefForAnimation",
    "startAnimation",
    "opacity",
    "animate",
    "duration",
    "forwardRef",
    "TRANSPARENT_PNG_DATA_URL",
    "loadscreenCssUrl",
    "_empty",
    "LoadScreen",
    "urlLoadingState",
    "loadscreenRef",
    "loadscreenUrlTrackerReady",
    "loadscreenUrlsLoaded",
    "loadscreenUrlsLoadedSetter",
    "mainImportLoading",
    "mainImportLoadingSetter",
    "mainImportNamespace",
    "mainImportNamespaceSetter",
    "mainUrlTrackerReady",
    "mainUrlTrackerReadySetter",
    "mainUrlsLoaded",
    "mainsUrlsLoadedSetter",
    "mainUrlErrorSetter",
    "urlTrackerTotalCount",
    "urlTrackerLoadedCount",
    "filter",
    "useUrlTrackerLoadedCount",
    "splashscreen",
    "remove",
    "module",
    "namespace",
    "fill",
    "onfinish",
    "style",
    "display",
    "App",
    "id",
    "symbolSkullUrl",
    "className",
    "LowerLevelComponent",
    "ComponentDisplayedOnError",
    "Main",
    "maxWidth",
    "margin",
    "overflow",
    "stack",
    "subClass",
    "superClass",
    "TypeError",
    "create",
    "Constructor",
    "protoProps",
    "staticProps",
    "instance",
    "hasError",
    "Component"
  ],
  "mappings": "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"
}