{
  "version": 3,
  "file": "main.component.js",
  "sources": [
    "../../src/helper/asap.js",
    "../../src/generic/Stylesheet.jsx",
    "../../node_modules/@jsenv/core/helpers/babel/objectWithoutProperties/objectWithoutProperties.js",
    "../../node_modules/@jsenv/core/helpers/babel/objectWithoutPropertiesLoose/objectWithoutPropertiesLoose.js",
    "../../src/dom/dom.util.js",
    "../../src/loading/loading.main.js",
    "../../node_modules/@jsenv/core/helpers/babel/createClass/createClass.js",
    "../../node_modules/@jsenv/core/helpers/babel/setPrototypeOf/setPrototypeOf.js",
    "../../node_modules/@jsenv/core/helpers/babel/getPrototypeOf/getPrototypeOf.js",
    "../../node_modules/@jsenv/core/helpers/babel/possibleConstructorReturn/possibleConstructorReturn.js",
    "../../node_modules/@jsenv/core/helpers/babel/assertThisInitialized/assertThisInitialized.js",
    "../../node_modules/@jsenv/core/helpers/babel/createSuper/createSuper.js",
    "../../node_modules/@jsenv/core/helpers/babel/isNativeReflectConstruct/isNativeReflectConstruct.js",
    "../../src/error/error.main.js",
    "../../src/loading/loading.hooks.js",
    "../../node_modules/@jsenv/pwa/src/internal/listenEvent.js",
    "../../node_modules/@jsenv/pwa/src/navigatorController.js",
    "../../node_modules/@jsenv/pwa/src/internal/createSignal.js",
    "../../node_modules/@jsenv/pwa/src/internal/sendMessageUsingChannel.js",
    "../../src/loading/loadImage.js",
    "../../src/loading/preloadImages.js",
    "../../src/loading/Preloader.jsx",
    "../../node_modules/@jsenv/core/helpers/babel/extends/extends.js",
    "../../src/loading/useImage.js",
    "../../src/generic/OnceIntersectingSuspense.js",
    "../../src/generic/Image.jsx",
    "../../src/main.component.js",
    "../../node_modules/@jsenv/core/helpers/babel/inherits/inherits.js",
    "../../node_modules/@jsenv/core/helpers/babel/classCallCheck/classCallCheck.js"
  ],
  "sourcesContent": [
    "export const requestAsapCallback = window.requestIdleCallback\n  ? (callback) => {\n      const requestId = window.requestIdleCallback(callback, { timeout: 400 })\n      return () => {\n        window.cancelIdleCallback(requestId)\n      }\n    }\n  : (callback) => {\n      const requestId = window.requestAnimationFrame(callback)\n      return () => {\n        window.cancelAnimationFrame(requestId)\n      }\n    }\n",
    "/**\n\nThis component (Stylesheet) must ensure a given url is loaded as css by the browser.\nTo achieve that it creates a <link> and append it to document.head\n\nIt is important that even if many Stylesheet are instantiated for a given url only\none <link> ends up in the document.head. (Appended it multiple times is useless).\nIt happens for Dialog.base.css for instance.\n\nI have tried to achieve this with ReactDOM.createPortal but could not manage\nto have only one <link> injected.\n\n*/\n\nimport React from \"react\"\nimport { addLoadedListener, useUrlLoadingNotifier } from \"src/loading/loading.main.js\"\n\nexport const Stylesheet = ({ href }) => {\n  const [fetchEnd] = useUrlLoadingNotifier(href)\n\n  React.useEffect(() => {\n    return injectStylesheetIntoDocument(href, { onload: fetchEnd })\n  }, [href])\n\n  return null\n}\n\nconst memoizeLinksByHref = (fn) => {\n  const linkMap = new Map()\n\n  const stopUsing = (href) => {\n    if (!linkMap.has(href)) {\n      return\n    }\n\n    const { useCount, ...rest } = linkMap.get(href)\n    if (useCount > 1) {\n      linkMap.set(href, {\n        useCount: useCount - 1,\n        ...rest,\n      })\n      return\n    }\n\n    linkMap.delete(href)\n    rest.linkCleanup()\n  }\n\n  return (href, ...args) => {\n    if (linkMap.has(href)) {\n      const { useCount, ...rest } = linkMap.get(href)\n      linkMap.set(href, {\n        useCount: useCount + 1,\n        ...rest,\n      })\n      return stopUsing\n    }\n\n    const linkCleanup = fn(href, ...args)\n    linkMap.set(href, {\n      useCount: 1,\n      linkCleanup,\n    })\n    return stopUsing\n  }\n}\n\nconst injectStylesheetIntoDocument = memoizeLinksByHref((href, { onload = () => {} } = {}) => {\n  const link = document.createElement(\"link\")\n  link.rel = \"stylesheet\"\n  link.type = \"text/css\"\n  const removeLoadedListener = addLoadedListener(link, onload)\n  link.href = href\n  document.head.appendChild(link)\n  return () => {\n    removeLoadedListener()\n    document.head.removeChild(link)\n  }\n})\n",
    "import objectWithoutPropertiesLoose from \"../objectWithoutPropertiesLoose/objectWithoutPropertiesLoose.js\"\n\nexport default (source, excluded) => {\n  if (source === null) return {}\n\n  var target = objectWithoutPropertiesLoose(source, excluded)\n  var key\n  var i\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source)\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i]\n      if (excluded.indexOf(key) >= 0) continue\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue\n      target[key] = source[key]\n    }\n  }\n  return target\n}\n",
    "export default (source, excluded) => {\n  if (source === null) return {}\n  var target = {}\n  var sourceKeys = Object.keys(source)\n  var key\n  var i\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i]\n    if (excluded.indexOf(key) >= 0) continue\n    target[key] = source[key]\n  }\n  return target\n}\n",
    "/* eslint-disable valid-jsdoc */\n\nexport const addDomEventListener = (domNode, eventName, callback, options) => {\n  domNode.addEventListener(eventName, callback, options)\n  return () => {\n    domNode.removeEventListener(eventName, callback, options)\n  }\n}\n\n// checking if somthing is window is tricky\n// we could also use a.constructor.name === 'Window'\n// but it's safer to use approach below\nexport const elementIsWindow = (a) => a.window === a\n\nexport const elementIsDocument = (a) => a.nodeType === 9\n\nexport const elementIsIframe = ({ nodeName }) => nodeName === \"IFRAME\"\n\nexport const isFocusable = (node) => {\n  // only element node can be focused, document, textNodes etc cannot\n  if (node.nodeType !== 1) {\n    return false\n  }\n  const nodeName = node.nodeName.toLowerCase()\n\n  if (nodeName === \"input\") {\n    if (node.type === \"hidden\") {\n      return false\n    }\n    return isVisible(node)\n  }\n\n  if ([\"button\", \"select\", \"datalist\", \"iframe\", \"textarea\"].indexOf(nodeName) > -1) {\n    return isVisible(node)\n  }\n\n  if (node.hasAttribute(\"tabindex\") || node.hasAttribute(\"tabIndex\")) {\n    return isVisible(node)\n  }\n\n  if (node.hasAttribute(\"draggable\")) {\n    return isVisible(node)\n  }\n\n  if ([\"a\", \"area\"].indexOf(nodeName) > -1) {\n    if (node.hasAttribute(\"href\") === false) {\n      return false\n    }\n    return isVisible(node)\n  }\n\n  if ([\"audio\", \"video\"].indexOf(nodeName) > -1) {\n    if (node.hasAttribute(\"controls\") === false) {\n      return false\n    }\n    return isVisible(node)\n  }\n\n  return false\n}\n\nexport const isVisible = (node) => {\n  if (isDocumentElement(node)) {\n    return true\n  }\n  if (getStyleValue(node, \"visibility\") === \"hidden\") {\n    return false\n  }\n\n  let nodeOrAncestor = node\n  while (nodeOrAncestor) {\n    if (isDocumentElement(nodeOrAncestor)) {\n      break\n    }\n    if (getStyleValue(nodeOrAncestor, \"display\") === \"none\") {\n      return false\n    }\n    nodeOrAncestor = nodeOrAncestor.parentNode\n  }\n\n  return true\n}\n\n// https://github.com/davidtheclark/tabbable/blob/master/index.js\nexport const isDocumentElement = (node) => node === node.ownerDocument.documentElement\n\nexport const getStyle = (element) => elementToOwnerWindow(element).getComputedStyle(element)\n\nexport const getStyleValue = (element, name) => getStyle(element).getPropertyValue(name)\n\n/**\n * elementToOwnerWindow returns the window owning the element.\n * Usually an element window will just be window.\n * But when an element is inside an iframe, the window of that element\n * is iframe.contentWindow\n * It's often important to work with the correct window because\n * element are scoped per iframes.\n */\nexport const elementToOwnerWindow = (element) => {\n  if (elementIsWindow(element)) return element\n\n  if (elementIsDocument(element)) return element.defaultView\n\n  return elementToOwnerDocument(element).defaultView\n}\n\n/**\n * elementToOwnerDocument returns the document containing the element.\n * Usually an element document is window.document.\n * But when an element is inside an iframe, the document of that element\n * is iframe.contentWindow.document\n * It's often important to work with the correct document because\n * element are scoped per iframes.\n */\nexport const elementToOwnerDocument = (element) => {\n  if (elementIsWindow(element)) return element.document\n\n  if (elementIsDocument(element)) return element\n\n  return element.ownerDocument\n}\n\nexport const getDocumentScroll = (element) => {\n  const elementWindow = elementToOwnerWindow(element)\n  const elementDocument = elementToOwnerDocument(element)\n  return {\n    x: elementWindow.pageXOffset || elementDocument.documentElement.scrollLeft,\n    y: elementWindow.pageYOffset || elementDocument.documentElement.scrollTop,\n  }\n}\n\n/**\n * elementToOwnerIframe returns the iframe owning the element or null\n * when element is not inside an iframe.\n */\nexport const elementToOwnerIframe = (element) => {\n  const elementOwnerWindow = elementToOwnerWindow(element)\n  // element is not inside an iframe because it is owned by window\n  // if element is window itself, elementOwnerWindow is window too\n  // because elementToOwnerWindow(window) returns window\n  if (elementOwnerWindow === window) return null\n\n  const parentDocument = elementOwnerWindow.parent.document\n  return Array.from(parentDocument.querySelectorAll(\"iframe\")).find(\n    (iframe) => iframeIsFriendly(iframe) && iframe.contentWindow.document.contains(element),\n  )\n}\n\n/**\n * This function is used to ensure we are allowed to manipulate an iframe.\n * If we don't do this check before doing stuff like adding 'mousemove' event\n * to the iframe, it will throw an error.\n * A friendly iframe is usually an iframe with src set to 'about:blank'.\n * The opposite of a friendly iframe is an iframe on an other domain.\n */\nexport const iframeIsFriendly = (iframe) => {\n  const key = `${Number(new Date())}${Math.random()}`\n  const value = {}\n\n  try {\n    const iframeWindow = iframe.contentWindow\n    iframeWindow[key] = value\n    const isFriendly = iframeWindow[key] === value\n    delete iframeWindow[key]\n    return isFriendly\n  } catch (e) {\n    return false\n  }\n}\n",
    "import React from \"react\"\nimport { addDomEventListener } from \"src/dom/dom.util.js\"\n\nconst UrlLoadingContext = React.createContext()\nconst reducer = (state, action) => action(state)\nconst initialState = {}\n\nconst logs = false\n\nexport const UrlLoadingProvider = ({ children }) => {\n  return (\n    <UrlLoadingContext.Provider value={React.useReducer(reducer, initialState)}>\n      {children}\n    </UrlLoadingContext.Provider>\n  )\n}\n\nexport const useUrlTrackerTotalCount = () => {\n  const urlLoadingState = useUrlLoadingState()\n  const totalCount = Object.keys(urlLoadingState).length\n  return totalCount\n}\n\nexport const useUrlTrackerLoadedCount = () => {\n  const urlLoadingState = useUrlLoadingState()\n  const loadedCount = Object.keys(urlLoadingState).filter(\n    (url) => urlLoadingState[url].status === \"loaded\",\n  ).length\n  return loadedCount\n}\n\nexport const useUrlTrackerAllLoaded = () => {\n  const totalCount = useUrlTrackerTotalCount()\n  const loadedCount = useUrlTrackerLoadedCount()\n  return loadedCount === totalCount\n}\n\nexport const useUrlLoadingNotifier = (url) => {\n  const contextValue = React.useContext(UrlLoadingContext)\n  if (!contextValue) {\n    // if (import.meta.dev) {\n    //   console.warn(`useUrlLoadingNotifier was called on a component without UrlLoadingContext`)\n    // }\n    return [() => {}, () => {}]\n  }\n\n  const dispatch = contextValue[1]\n\n  const fetchStart = () => {\n    dispatch((state) => {\n      if (url in state) {\n        // console.log(\"start loading early return\", url, state[url])\n        return state\n      }\n      if (logs) {\n        console.log(\"start loading\", url)\n      }\n      return {\n        ...state,\n        [url]: { status: \"loading\" },\n      }\n    })\n  }\n\n  const fetchAbort = () => {\n    dispatch((state) => {\n      if (!state.hasOwnProperty(url)) {\n        return state\n      }\n\n      const status = state[url].status\n      if (status !== \"loading\") {\n        return state\n      }\n\n      const stateWithoutUrl = {}\n      Object.keys(state).forEach((key) => {\n        if (key !== url) {\n          stateWithoutUrl[key] = state[key]\n        }\n      })\n\n      return stateWithoutUrl\n    })\n  }\n\n  const fetchEnd = () => {\n    dispatch((state) => {\n      if (url in state && state[url].status === \"loaded\") {\n        // console.log(\"end loading early return\", url, state[url])\n        return state\n      }\n      if (logs) {\n        console.log(\"end loading\", url)\n      }\n      return {\n        ...state,\n        [url]: { status: \"loaded\" },\n      }\n    })\n  }\n\n  React.useEffect(() => {\n    fetchStart()\n    return () => {\n      fetchAbort()\n    }\n  }, [])\n\n  return [fetchEnd, fetchAbort]\n}\n\nexport const useDOMNodeLoadingNotifier = (url) => {\n  const [domNodeFetchEnd] = useUrlLoadingNotifier(url)\n\n  const nodeRefCallback = React.useCallback(\n    (node) => {\n      if (node) {\n        return addLoadedListener(node, domNodeFetchEnd)\n      }\n      return undefined\n    },\n    [domNodeFetchEnd],\n  )\n\n  return nodeRefCallback\n}\n\nconst useUrlLoadingState = () => {\n  const contextValue = React.useContext(UrlLoadingContext)\n  if (!contextValue) {\n    // if (import.meta.dev) {\n    //   console.warn(`useUrlLoadingState was called on a component without UrlLoadingContext`)\n    // }\n    return null\n  }\n  return contextValue[0]\n}\n\nexport const useSingleUrlLoadingTracker = (url) => useUrlLoadingState()[url]\n\nexport const addLoadedListener = (domNode, callback) => {\n  const removeLoadListener = addDomEventListener(domNode, \"load\", () => {\n    removeErrorListener()\n    callback()\n  })\n  const removeErrorListener = addDomEventListener(domNode, \"error\", () => {\n    removeLoadListener()\n    callback()\n  })\n\n  return () => {\n    removeLoadListener()\n    removeErrorListener()\n  }\n}\n",
    "export default (Constructor, protoProps, staticProps) => {\n  if (protoProps) defineProperties(Constructor.prototype, protoProps)\n  if (staticProps) defineProperties(Constructor, staticProps)\n  return Constructor\n}\n\nfunction defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i]\n    descriptor.enumerable = descriptor.enumerable || false\n    descriptor.configurable = true\n    if (\"value\" in descriptor) descriptor.writable = true\n    Object.defineProperty(target, descriptor.key, descriptor)\n  }\n}\n",
    "export default Object.setPrototypeOf ||\n  ((o, p) => {\n    // eslint-disable-next-line no-proto\n    o.__proto__ = p\n    return o\n  })\n",
    "export default Object.setPrototypeOf\n  ? Object.getPrototypeOf\n  : // eslint-disable-next-line no-proto\n    (o) => o.__proto__ || Object.getPrototypeOf(o)\n",
    "import assertThisInitialized from \"../assertThisInitialized/assertThisInitialized.js\"\n\nexport default (self, call) => {\n  if (call && (typeof call === \"object\" || typeof call === \"function\")) {\n    return call\n  }\n  return assertThisInitialized(self)\n}\n",
    "export default (self) => {\n  // eslint-disable-next-line no-void\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\")\n  }\n  return self\n}\n",
    "import getPrototypeOf from \"../getPrototypeOf/getPrototypeOf.js\"\nimport isNativeReflectConstruct from \"../isNativeReflectConstruct/isNativeReflectConstruct.js\"\nimport possibleConstructorReturn from \"../possibleConstructorReturn/possibleConstructorReturn.js\"\n\nexport default function _createSuper(Derived) {\n  var hasNativeReflectConstruct = isNativeReflectConstruct()\n\n  return function _createSuperInternal() {\n    var Super = getPrototypeOf(Derived)\n    var result\n    if (hasNativeReflectConstruct) {\n      // NOTE: This doesn't work if this.__proto__.constructor has been modified.\n      var NewTarget = getPrototypeOf(this).constructor\n      // eslint-disable-next-line prefer-rest-params\n      result = Reflect.construct(Super, arguments, NewTarget)\n    } else {\n      // eslint-disable-next-line prefer-rest-params\n      result = Super.apply(this, arguments)\n    }\n    return possibleConstructorReturn(this, result)\n  }\n}\n",
    "export default function isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false\n  // core-js@3\n  if (Reflect.construct.sham) return false\n  // Proxy can't be polyfilled. Every browser implemented\n  // proxies before or at the same time as Reflect.construct,\n  // so if they support Proxy they also support Reflect.construct.\n  if (typeof Proxy === \"function\") return true\n  // Since Reflect.construct can't be properly polyfilled, some\n  // implementations (e.g. core-js@2) don't set the correct internal slots.\n  // Those polyfills don't allow us to subclass built-ins, so we need to\n  // use our fallback implementation.\n  try {\n    // If the internal slots aren't set, this throws an error similar to\n    //   TypeError: this is not a Date object.\n    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}))\n    return true\n  } catch (e) {\n    return false\n  }\n}\n",
    "import React from \"react\"\n\nexport const catchError = (LowerLevelComponent, ComponentDisplayedOnError) => {\n  class ErrorBoundary extends React.Component {\n    constructor(props) {\n      super(props)\n      this.state = {\n        hasError: false,\n        error: null,\n      }\n    }\n\n    static getDerivedStateFromError(error) {\n      return {\n        hasError: true,\n        error,\n      }\n    }\n\n    render() {\n      if (this.state.hasError) {\n        return <ComponentDisplayedOnError error={this.state.error} />\n      }\n      return <LowerLevelComponent {...this.props} />\n    }\n  }\n\n  return ErrorBoundary\n}\n",
    "import React from \"react\"\nimport { requestAsapCallback } from \"src/helper/asap.js\"\n\nexport const useWaitABit = () => {\n  const [waited, waitedSetter] = React.useState(false)\n  React.useEffect(() => {\n    return requestAsapCallback(() => {\n      waitedSetter(true)\n    })\n  }, [])\n  return waited\n}\n",
    "export const listenEvent = (objectWithEventEmitter, event, callback) => {\n  objectWithEventEmitter.addEventListener(event, callback)\n  return () => {\n    objectWithEventEmitter.removeEventListener(event, callback)\n  }\n}\n",
    "// do not forget error handling: https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorkerContainer/onerror\n\nimport { createSignal } from \"./internal/createSignal.js\"\nimport { listenEvent } from \"./internal/listenEvent.js\"\nimport { sendMessageUsingChannel } from \"./internal/sendMessageUsingChannel.js\"\n\nconst serviceWorkerAPI = window.navigator.serviceWorker\n\nexport const canUseServiceWorker = Boolean(serviceWorkerAPI)\n\n// https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorkerRegistration\nlet registrationPromise = null\nlet serviceWorker = null\nconst serviceWorkerSetter = (worker) => {\n  serviceWorker = worker\n}\n\nlet serviceWorkerUpdating = null\nconst serviceWorkerUpdatingChangeSignal = createSignal()\nconst serviceWorkerUpdatingSetter = (worker) => {\n  if (serviceWorkerUpdating && serviceWorkerUpdating === worker) {\n    // we already know about this worker, no need to listen state changes.\n    // it happens for manual updates where we bot detect it\n    // from registration.update() return value\n    // and \"updatefound\" event\n    console.log(\"we already know this worker is updating\")\n    return\n  }\n  if (worker) {\n    console.log(`found a worker updating (worker state is: ${worker.state})`)\n  } else {\n    console.log(`worker update is done`)\n  }\n  serviceWorkerUpdating = worker\n  serviceWorkerUpdatingChangeSignal.emit()\n}\n\nexport const serviceWorkerIsAvailable = () => Boolean(registrationPromise)\n\nexport const registerServiceWorker = (url, { scope } = {}) => {\n  if (!canUseServiceWorker) {\n    return () => {}\n  }\n\n  let unregistered = false\n  let unregister = () => {}\n  let removeUpdateFoundListener = () => {}\n\n  registrationPromise = serviceWorkerAPI.register(url, { scope })\n  ;(async () => {\n    const registration = await registrationPromise\n    unregister = () => {\n      registration.unregister()\n    }\n\n    if (unregistered) {\n      unregister()\n      return\n    }\n\n    const { installing, waiting, active } = registration\n    serviceWorkerSetter(installing || waiting || active)\n    removeUpdateFoundListener = listenEvent(registration, \"updatefound\", () => {\n      console.log(\"browser notifies use an worker is installing\")\n      if (registration.installing === installing) {\n        console.log(`it's not an worker update, it's first time worker registers`)\n        return\n      }\n      serviceWorkerUpdatingSetter(registration.installing)\n    })\n  })()\n\n  return () => {\n    unregistered = true\n    removeUpdateFoundListener()\n    unregister()\n  }\n}\n\n// export const getServiceWorkerState = () => {\n//   if (serviceWorker) {\n//     return serviceWorker.state\n//   }\n//   return null\n// }\n\n// export const listenServiceWorkerState = (callback) => {\n//   let removeStateChangeListener = () => {}\n//   const removeWorkerChangeListener = serviceWorkerChangeSignal.listen(() => {\n//     callback()\n//     removeStateChangeListener = listenEvent(serviceWorker, \"statechange\", callback)\n//   })\n//   return () => {\n//     removeWorkerChangeListener()\n//     removeStateChangeListener()\n//   }\n// }\n\n// For now this function will try to communicate with the old service worker\n// even if new worker is activating or activated.\n// It might not work because, from what I understood, the old worker gets killed\n// by the navigator as soon as the new worker starts to activate.\n// Maybe it should communicate with the new worker as soon as we know\n// updating worker is activating or activated.\n// -> yes\nexport const sendMessageToServiceWorker = (message) => {\n  if (!serviceWorker) {\n    console.warn(`no service worker to send message to`)\n    return undefined\n  }\n  return sendMessageUsingChannel(serviceWorker, message)\n}\n\nexport const getServiceWorkerUpdate = () => {\n  return serviceWorkerUpdating\n    ? {\n        shouldBecomeNavigatorController: Boolean(serviceWorkerAPI.controller),\n        navigatorWillReload: autoReloadEnabled,\n      }\n    : null\n}\n\nexport const listenServiceWorkerUpdate = (callback) => {\n  return serviceWorkerUpdatingChangeSignal.listen(callback)\n}\n\nexport const checkServiceWorkerUpdate = async () => {\n  if (!registrationPromise) {\n    console.warn(`registerServiceWorker must be called before checkServiceWorkerUpdate can be used`)\n    return false\n  }\n\n  const registration = await registrationPromise\n  const updateRegistration = await registration.update()\n\n  const { installing } = updateRegistration\n  if (installing) {\n    console.log(\"installing worker found after calling update()\")\n    serviceWorkerUpdatingSetter(installing)\n    return true\n  }\n\n  const { waiting } = updateRegistration\n  if (waiting) {\n    console.log(\"waiting worker found after calling update()\")\n    serviceWorkerUpdatingSetter(waiting)\n    return true\n  }\n\n  console.log(\"no worker found after calling update()\")\n  return false\n}\n\nexport const sendMessageToServiceWorkerUpdate = (message) => {\n  if (!serviceWorkerUpdating) {\n    console.warn(`no service worker updating to send message to`)\n    return undefined\n  }\n  return sendMessageUsingChannel(serviceWorkerUpdating, message)\n}\n\nexport const activateServiceWorkerUpdate = async (params) => {\n  if (!serviceWorkerUpdating) {\n    throw new Error(\"no service worker update to activate\")\n  }\n  return sendSkipWaitingToWorker(serviceWorkerUpdating, params)\n}\n\nconst sendSkipWaitingToWorker = async (\n  worker,\n  { onActivating = () => {}, onActivated = () => {}, onBecomesNavigatorController = () => {} } = {},\n) => {\n  const { state } = worker\n  const waitUntilActivated = () => {\n    return new Promise((resolve) => {\n      const removeStateChangeListener = listenEvent(worker, \"statechange\", () => {\n        if (worker.state === \"activating\") {\n          serviceWorkerSetter(serviceWorkerUpdating)\n          onActivating()\n        }\n        if (worker.state === \"activated\") {\n          serviceWorkerSetter(serviceWorkerUpdating)\n          onActivated()\n          removeStateChangeListener()\n          resolve()\n        }\n      })\n    })\n  }\n\n  // worker must be waiting (meaning state must be \"installed\")\n  // to be able to call skipWaiting on it.\n  // If it's installing it's an error.\n  // If it's activating, we'll just skip the skipWaiting call\n  // If it's activated, we'll just return early\n  if (state === \"installed\" || state === \"activating\") {\n    if (state === \"installed\") {\n      sendMessageToServiceWorkerUpdate({ action: \"skipWaiting\" })\n    }\n    if (state === \"activating\") {\n      serviceWorkerSetter(serviceWorkerUpdating)\n    }\n    await waitUntilActivated()\n\n    if (serviceWorkerAPI.controller) {\n      const removeControllerChangeListener = listenEvent(\n        serviceWorkerAPI,\n        \"controllerchange\",\n        () => {\n          removeControllerChangeListener()\n          onBecomesNavigatorController()\n          serviceWorkerUpdatingSetter(null)\n          if (autoReloadEnabled) reload()\n        },\n      )\n    } else {\n      serviceWorkerUpdatingSetter(null)\n      if (autoReloadEnabled) reload()\n    }\n    return\n  }\n\n  serviceWorkerSetter(serviceWorkerUpdating)\n  onBecomesNavigatorController()\n  serviceWorkerUpdatingSetter(null)\n  if (autoReloadEnabled) reload()\n}\n\nlet autoReloadEnabled = true\nlet disableAutoReload = () => {}\nexport const autoReloadAfterUpdateIsEnabled = () => autoReloadEnabled\nexport const disableAutoReloadAfterUpdate = () => disableAutoReload()\n\nlet refreshing = false\nconst reload = () => {\n  if (refreshing) {\n    return\n  }\n  refreshing = true\n  window.location.reload()\n}\n\nif (canUseServiceWorker) {\n  const removeControllerChangeListener = listenEvent(serviceWorkerAPI, \"controllerchange\", reload)\n\n  disableAutoReload = () => {\n    autoReloadEnabled = false\n    removeControllerChangeListener()\n  }\n}\n\n// const navigatorIsControlledByAServiceWorker = () => {\n//   return canUseServiceWorker ? Boolean(serviceWorkerAPI.controller) : false\n// }\n\n// const getServiceWorkerControllingNavigator = () => {\n//   return navigatorIsControlledByAServiceWorker() ? serviceWorkerAPI.controller : null\n// }\n",
    "export const createSignal = () => {\n  let listeners = []\n\n  const listen = (callback, { once = false } = {}) => {\n    if (once) {\n      const callbackOriginal = callback\n      callback = (...args) => {\n        stopListening()\n        callbackOriginal(...args)\n      }\n    }\n\n    listeners = [...listeners, callback]\n\n    let removed = false\n    const stopListening = () => {\n      if (removed) return\n      removed = true\n      const listenersWithoutCallback = []\n      let i = listeners.length\n      let searching = true\n      while (i--) {\n        const listenerCandidate = listeners[i]\n        if (searching) {\n          if (listenerCandidate === callback) {\n            searching = false\n          } else {\n            listenersWithoutCallback.push(listenerCandidate)\n          }\n        } else {\n          listenersWithoutCallback.push(listenerCandidate)\n        }\n      }\n      listeners = listenersWithoutCallback\n    }\n    return stopListening\n  }\n\n  const emit = (...args) => {\n    listeners.forEach((listener) => {\n      listener(...args)\n    })\n  }\n\n  return {\n    listen,\n    emit,\n  }\n}\n",
    "// https://felixgerschau.com/how-to-communicate-with-service-workers/\nexport const sendMessageUsingChannel = (objectWithPostMessage, message) => {\n  const { port1, port2 } = new MessageChannel()\n  return new Promise((resolve, reject) => {\n    port1.onmessage = function (event) {\n      if (event.data.status === \"rejected\") {\n        reject(event.data.value)\n      } else {\n        resolve(event.data.value)\n      }\n    }\n    objectWithPostMessage.postMessage(message, [port2])\n  })\n}\n",
    "// https://vincenttaverna.com/posts/react-image-hook/\nexport const loadImage = (url, crossOrigin) => {\n  const image = new Image()\n\n  if (crossOrigin) {\n    image.crossOrigin = crossOrigin\n  }\n\n  return new Promise((resolve, reject) => {\n    // Load Handler\n    const loaded = (event) => {\n      // Cleanup our image element, we no longer need it\n      unbindEvents(image)\n      // Fulfill our promise with the event image element, even in older browsers\n      resolve(event.target || event.srcElement)\n    }\n\n    // Error Handler\n    const errored = (error) => {\n      // Cleanup our image element, we no longer need it\n      unbindEvents(image)\n      // Forward our error to the user\n      reject(error)\n    }\n\n    // Set our handlers\n    image.onload = loaded\n    image.onerror = errored\n    image.onabort = errored\n\n    // Tell the browser we are ready to begin downloading\n    image.src = url\n  })\n}\n\nconst unbindEvents = (image) => {\n  // Reset callbacks\n  image.onload = null\n  image.onerror = null\n  image.onabort = null\n\n  try {\n    // Some browsers need you to remove the src\n    // in order to garbage collect the image object\n    delete image.src\n  } catch (e) {\n    // Safari's strict mode throws, ignore\n  }\n}\n",
    "import { loadImage } from \"./loadImage.js\"\n\nexport const preloadImages = async (\n  images,\n  { chunkSize = 7, msDelayBetweenChunks = 2000 } = {},\n) => {\n  let index = 0\n  const loaded = {}\n  const failed = {}\n\n  const preloadChunk = async (chunk) => {\n    await Promise.all(\n      chunk.map(async (src) => {\n        try {\n          const image = await loadImage(src)\n          loaded[src] = image\n        } catch (error) {\n          failed[src] = true\n        }\n      }),\n    )\n    await new Promise((resolve) => {\n      setTimeout(resolve, msDelayBetweenChunks)\n    })\n    const nextChunk = getNextChunk()\n    if (nextChunk.length > 0) {\n      await preloadChunk(nextChunk)\n    }\n  }\n\n  const getNextChunk = () => {\n    const chunk = []\n    let i = 0\n    while (i < chunkSize && index < images.length) {\n      chunk.push(images[index])\n      i++\n      index++\n    }\n    return chunk\n  }\n\n  await preloadChunk(getNextChunk())\n\n  return { loaded, failed }\n}\n",
    "/* eslint-disable import/max-dependencies */\nimport React from \"react\"\nimport { registerServiceWorker } from \"@jsenv/pwa\"\n\nimport { cardDefaultUrl, cardImageUrlMap } from \"src/cards/cards.js\"\nimport { preloadImages } from \"src/loading/preloadImages.js\"\nimport { useWaitABit } from \"./loading.hooks.js\"\n\nconst woodUrl = new URL(\"/src/wood.jpg\", import.meta.url)\nconst pirateHookUrl = new URL(\"/src/chest/pirate-hook.png\", import.meta.url)\nconst pirateHook2Url = new URL(\"/src/chest/pirate-hook-02.png\", import.meta.url)\nconst woodBoxUrl = new URL(\"/src/chest/wood-box.jpg\", import.meta.url)\nconst treasureMapUrl = new URL(\"/src/dice-ongoing/treasure-map.png\", import.meta.url)\nconst witchLabelUrl = new URL(\"/src/skull-island/witch-label.png\", import.meta.url)\nconst skullBottleUrl = new URL(\"/src/skull-island/skull-bottle.png\", import.meta.url)\n\nexport const Preloader = () => {\n  const waited = useWaitABit()\n\n  React.useEffect(() => {\n    if (waited) {\n      registerServiceWorker(\"/service-worker.js\")\n    }\n  }, [waited])\n\n  return waited ? <ImagePreloader /> : null\n}\n\nconst ImagePreloader = () => {\n  const images = [\n    woodUrl,\n    pirateHookUrl,\n    pirateHook2Url,\n    woodBoxUrl,\n    treasureMapUrl,\n    witchLabelUrl,\n    skullBottleUrl,\n    cardDefaultUrl,\n    ...Object.keys(cardImageUrlMap).map((key) => cardImageUrlMap[key]),\n  ]\n\n  React.useEffect(() => {\n    const timeoutId = setTimeout(() => preloadImages(images), 2000)\n    return () => {\n      clearTimeout(timeoutId)\n    }\n  }, [])\n\n  return null\n}\n",
    "function assign(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    // eslint-disable-next-line prefer-rest-params\n    var source = arguments[i]\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key]\n      }\n    }\n  }\n  return target\n}\n\nexport default Object.assign || assign\n",
    "import React from \"react\"\nimport { loadImage } from \"./loadImage.js\"\n\nconst cache = new Map()\n\nexport const Status = {\n  LOADING: \"loading\",\n  LOADED: \"loaded\",\n  FAILED: \"failed\",\n}\n\nexport const useImage = (src) => {\n  const cachedImg = cache.get(src)\n  const initialState = cachedImg ? Status.LOADED : Status.LOADING\n  const [status, setStatus] = React.useState(initialState)\n  const mounted = React.useRef(false)\n\n  React.useEffect(() => {\n    if (!src || status === Status.LOADED) {\n      return () => {}\n    }\n    mounted.current = true\n    ;(async () => {\n      try {\n        const image = await loadImage(src)\n        if (!mounted.current) return\n\n        cache.set(src, image)\n        setStatus(Status.LOADED)\n      } catch (error) {\n        if (!mounted.current) return\n\n        cache.delete(src)\n        setStatus(Status.FAILED)\n      }\n    })()\n\n    return () => {\n      mounted.current = false\n    }\n  }, [src, status])\n\n  return [status, cachedImg]\n}\n",
    "import React from \"react\"\n\nexport const OnceIntersectingSuspense = ({\n  fallback,\n  root,\n  rootMargin,\n  threshold = 0,\n  children,\n}) => {\n  const [isIntersecting, isIntersectingSetter] = React.useState(false)\n  const [node, nodeSetter] = React.useState(null)\n\n  React.useEffect(() => {\n    if (!node) {\n      return () => {}\n    }\n    if (isIntersecting) {\n      return () => {}\n    }\n\n    // https://developer.mozilla.org/fr/docs/Web/API/Intersection_Observer_API\n    const observer = new window.IntersectionObserver(\n      ([entry]) => {\n        if (entry.isIntersecting) {\n          observer.unobserve(node)\n          isIntersectingSetter(true)\n        } else {\n          isIntersectingSetter(false)\n        }\n      },\n      {\n        root,\n        rootMargin,\n        threshold,\n      },\n    )\n    observer.observe(node)\n\n    return () => {\n      observer.disconnect()\n    }\n  }, [node, isIntersecting])\n\n  if (!isIntersecting) {\n    return fallback({ ref: nodeSetter })\n  }\n\n  return <>{children}</>\n}\n",
    "import React from \"react\"\n\nimport { useUrlLoadingNotifier } from \"src/loading/loading.main.js\"\nimport { useImage } from \"src/loading/useImage.js\"\nimport { OnceIntersectingSuspense } from \"./OnceIntersectingSuspense.js\"\n\nexport const Image = ({\n  loadWhenIntersecting = true,\n  usePlaceholderWhileLoading = true,\n  animateLoaded = true,\n\n  intersectionRoot,\n  intersectionRootMargin,\n  intersectionThreshold,\n  FallbackWhileNotIntersecting = ImageNotIntersectingFallback,\n  FallbackWhileLoading = ImageLoadingFallback,\n  useImageStatusHook = useImage,\n\n  src,\n  ...props\n}) => {\n  const [status] = useImageStatusHook(src)\n  const [imageFetchEnd] = useUrlLoadingNotifier(src)\n  React.useEffect(() => {\n    if (status === \"loaded\") {\n      imageFetchEnd()\n    }\n  }, [status])\n\n  let Component = <img src={src} {...props} />\n\n  if (animateLoaded) {\n    Component = <AnimateImageLoaded status={status} src={src} imageProps={props} />\n  }\n\n  if (usePlaceholderWhileLoading && status !== \"loaded\") {\n    const ComponentPrevious = Component\n    Component = (\n      <OnceImageLoadedSuspense status={status} fallback={<FallbackWhileLoading {...props} />}>\n        {ComponentPrevious}\n      </OnceImageLoadedSuspense>\n    )\n  }\n\n  if (loadWhenIntersecting && status !== \"loaded\") {\n    const ComponentPrevious = Component\n    Component = (\n      <OnceIntersectingSuspense\n        fallback={({ ref }) => <FallbackWhileNotIntersecting ref={ref} {...props} />}\n        root={intersectionRoot}\n        rootMargin={intersectionRootMargin}\n        threshold={intersectionThreshold}\n      >\n        {ComponentPrevious}\n      </OnceIntersectingSuspense>\n    )\n  }\n\n  return Component\n}\n\nconst AnimateImageLoaded = ({ status, src, imageProps }) => {\n  const mountedRef = React.useRef(false)\n  const nodeRef = React.useRef()\n  const statusRef = React.useRef(status)\n\n  React.useLayoutEffect(() => {\n    const mounted = mountedRef.current\n    const node = nodeRef.current\n    const statusPrevious = statusRef.current\n    mountedRef.current = true\n    statusRef.current = status\n\n    // ça ne marche pas vraiment parce que ce composant est mount\n    // que lorsque l'image est load et du coup il n'y aura pas d'animation\n    // mais bon quelque part l'image étant déja loadé il n'y a pas d'animation\n    // et c'est ce qu'on veut\n    if (mounted && statusPrevious !== status && status === \"loaded\") {\n      const opacity = window.getComputedStyle(node).getPropertyValue(\"opacity\")\n      node.animate([{ opacity: 0 }, { opacity }], {\n        duration: 300,\n      })\n    }\n  }, [status, nodeRef])\n\n  return <img ref={nodeRef} src={src} {...imageProps} />\n}\n\nconst OnceImageLoadedSuspense = ({ fallback, status, children }) => {\n  if (status !== \"loaded\") {\n    return fallback\n  }\n  return children\n}\n\n// eslint-disable-next-line react/display-name\nconst ImageLoadingFallback = React.forwardRef((props, ref) => {\n  return <img src={TRANSPARENT_PNG_DATA_URL} ref={ref} {...props} />\n})\n\n// eslint-disable-next-line react/display-name\nconst ImageNotIntersectingFallback = React.forwardRef((props, ref) => {\n  return <img src={TRANSPARENT_PNG_DATA_URL} ref={ref} {...props} />\n})\n\nconst TRANSPARENT_PNG_DATA_URL =\n  \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNkYAAAAAYAAjCB0C8AAAAASUVORK5CYII=\"\n",
    "/* eslint-disable import/max-dependencies */\nimport React from \"react\"\nimport { requestAsapCallback } from \"src/helper/asap.js\"\nimport { Stylesheet } from \"src/generic/Stylesheet.jsx\"\nimport { catchError } from \"src/error/error.main.js\"\nimport {\n  UrlLoadingProvider,\n  useUrlTrackerTotalCount,\n  useUrlTrackerLoadedCount,\n} from \"src/loading/loading.main.js\"\nimport { useWaitABit } from \"src/loading/loading.hooks.js\"\nimport { Preloader } from \"src/loading/Preloader.jsx\"\nimport { symbolSkullUrl } from \"src/symbols/symbols.js\"\nimport { Image } from \"src/generic/Image.jsx\"\n\nconst loadscreenCssUrl = new URL(\"../loadscreen.css\", import.meta.url)\n\nconst MainRaw = (props) => {\n  return (\n    <UrlLoadingProvider>\n      <LoadScreen {...props}></LoadScreen>\n    </UrlLoadingProvider>\n  )\n}\n\nconst LoadScreen = (props) => {\n  const loadscreenRef = React.useRef()\n  const loadscreenUrlTrackerReady = useWaitABit()\n  const [loadscreenUrlsLoaded, loadscreenUrlsLoadedSetter] = React.useState(false)\n\n  // main must wait for loadscreen + request idle callback before starting\n  const [mainImportLoading, mainImportLoadingSetter] = React.useState(false)\n  const [mainImportNamespace, mainImportNamespaceSetter] = React.useState(null)\n  const [mainUrlTrackerReady, mainUrlTrackerReadySetter] = React.useState(false)\n  const [mainUrlsLoaded, mainsUrlsLoadedSetter] = React.useState(false)\n  const [, mainUrlErrorSetter] = React.useState()\n\n  const urlTrackerTotalCount = useUrlTrackerTotalCount()\n  const urlTrackerLoadedCount = useUrlTrackerLoadedCount()\n\n  React.useEffect(() => {\n    if (loadscreenUrlTrackerReady && urlTrackerLoadedCount === urlTrackerTotalCount) {\n      loadscreenUrlsLoadedSetter(true)\n    }\n  }, [loadscreenUrlTrackerReady, urlTrackerLoadedCount, urlTrackerTotalCount])\n\n  React.useEffect(() => {\n    if (!loadscreenUrlsLoaded) {\n      return\n    }\n\n    window.splashscreen.remove()\n\n    mainImportLoadingSetter(true)\n    ;(async () => {\n      try {\n        const namespace = await import(\"./App.jsx\")\n        mainImportLoadingSetter(false)\n        mainImportNamespaceSetter(namespace)\n        requestAsapCallback(() => {\n          mainUrlTrackerReadySetter(true)\n        })\n      } catch (e) {\n        // https://github.com/facebook/react/issues/14981\n        mainUrlErrorSetter(() => {\n          throw e\n        })\n      }\n    })()\n  }, [loadscreenUrlsLoaded])\n\n  React.useEffect(() => {\n    if (mainUrlTrackerReady && urlTrackerLoadedCount === urlTrackerTotalCount) {\n      mainsUrlsLoadedSetter(true)\n    }\n  }, [mainUrlTrackerReady, urlTrackerLoadedCount, urlTrackerTotalCount])\n\n  React.useEffect(() => {\n    if (mainUrlsLoaded && loadscreenRef) {\n      const animation = loadscreenRef.current.animate([{ opacity: 1 }, { opacity: 0 }], {\n        duration: 300,\n        fill: \"forwards\",\n      })\n      animation.onfinish = () => {\n        loadscreenRef.current.style.display = \"none\"\n      }\n    }\n  }, [loadscreenRef, mainUrlsLoaded])\n\n  return (\n    <>\n      {mainImportNamespace ? <mainImportNamespace.App {...props} /> : null}\n      <div id=\"loadscreen\" ref={loadscreenRef}>\n        <Stylesheet href={loadscreenCssUrl} />\n        <Image src={symbolSkullUrl} animateLoaded={false} />\n        {mainImportLoading ? (\n          <p className=\"text\">Chargement du jeu...</p>\n        ) : (\n          <>\n            <p className=\"text\">Chargement du jeu...</p>\n            <div className=\"progress\">\n              {urlTrackerLoadedCount}/{urlTrackerTotalCount}\n            </div>\n          </>\n        )}\n      </div>\n      {mainUrlsLoaded ? <Preloader /> : null}\n    </>\n  )\n}\n\nconst ErrorScreen = ({ error }) => {\n  window.splashscreen.remove()\n  return (\n    <div style={{ maxWidth: \"100vw\" }}>\n      <div style={{ margin: \"10px 15px\" }}>An error occured</div>\n      <pre style={{ overflow: \"auto\", margin: \"10px 15px\" }}>\n        {typeof error === \"object\" ? error.stack : error}\n      </pre>\n    </div>\n  )\n}\n\nexport const Main = catchError(MainRaw, ErrorScreen)\n",
    "import setPrototypeOf from \"../setPrototypeOf/setPrototypeOf.js\"\n\nexport default (subClass, superClass) => {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\")\n  }\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true,\n    },\n  })\n  if (superClass) setPrototypeOf(subClass, superClass)\n}\n",
    "export default (instance, Constructor) => {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\")\n  }\n}\n"
  ],
  "names": [
    "fn",
    "linkMap",
    "stopUsing",
    "requestAsapCallback",
    "window",
    "requestIdleCallback",
    "callback",
    "requestId",
    "timeout",
    "cancelIdleCallback",
    "requestAnimationFrame",
    "cancelAnimationFrame",
    "source",
    "excluded",
    "key",
    "i",
    "target",
    "sourceKeys",
    "Object",
    "keys",
    "length",
    "indexOf",
    "objectWithoutPropertiesLoose",
    "getOwnPropertySymbols",
    "sourceSymbolKeys",
    "prototype",
    "propertyIsEnumerable",
    "call",
    "addDomEventListener",
    "domNode",
    "eventName",
    "options",
    "addEventListener",
    "removeEventListener",
    "elementIsWindow",
    "a",
    "elementIsDocument",
    "nodeType",
    "isVisible",
    "node",
    "nodeName",
    "toLowerCase",
    "type",
    "hasAttribute",
    "isDocumentElement",
    "getStyleValue",
    "nodeOrAncestor",
    "parentNode",
    "ownerDocument",
    "documentElement",
    "element",
    "name",
    "elementToOwnerWindow",
    "getComputedStyle",
    "getStyle",
    "getPropertyValue",
    "defaultView",
    "elementToOwnerDocument",
    "document",
    "UrlLoadingContext",
    "elementWindow",
    "elementDocument",
    "x",
    "pageXOffset",
    "scrollLeft",
    "y",
    "pageYOffset",
    "scrollTop",
    "React",
    "createContext",
    "reducer",
    "state",
    "action",
    "initialState",
    "UrlLoadingProvider",
    "children",
    "Provider",
    "value",
    "useReducer",
    "useUrlLoadingNotifier",
    "url",
    "contextValue",
    "useContext",
    "dispatch",
    "fetchAbort",
    "hasOwnProperty",
    "status",
    "stateWithoutUrl",
    "forEach",
    "useEffect",
    "useUrlLoadingState",
    "addLoadedListener",
    "removeLoadListener",
    "removeErrorListener",
    "Stylesheet",
    "href",
    "fetchEnd",
    "injectStylesheetIntoDocument",
    "onload",
    "link",
    "createElement",
    "rel",
    "removeLoadedListener",
    "head",
    "appendChild",
    "removeChild",
    "Map",
    "has",
    "get",
    "useCount",
    "rest",
    "set",
    "delete",
    "linkCleanup",
    "args",
    "defineProperties",
    "props",
    "descriptor",
    "enumerable",
    "configurable",
    "writable",
    "defineProperty",
    "setPrototypeOf",
    "o",
    "p",
    "__proto__",
    "getPrototypeOf",
    "self",
    "_typeof",
    "ReferenceError",
    "assertThisInitialized",
    "_createSuper",
    "Derived",
    "hasNativeReflectConstruct",
    "Reflect",
    "construct",
    "sham",
    "Proxy",
    "Date",
    "toString",
    "e",
    "isNativeReflectConstruct",
    "result",
    "Super",
    "NewTarget",
    "this",
    "constructor",
    "arguments",
    "apply",
    "possibleConstructorReturn",
    "useWaitABit",
    "useState",
    "waited",
    "waitedSetter",
    "listenEvent",
    "objectWithEventEmitter",
    "event",
    "_await",
    "then",
    "direct",
    "Promise",
    "resolve",
    "serviceWorkerAPI",
    "navigator",
    "serviceWorker",
    "f",
    "reject",
    "body",
    "listeners",
    "canUseServiceWorker",
    "Boolean",
    "registrationPromise",
    "serviceWorkerUpdating",
    "serviceWorkerUpdatingChangeSignal",
    "listen",
    "once",
    "callbackOriginal",
    "stopListening",
    "removed",
    "listenersWithoutCallback",
    "searching",
    "listenerCandidate",
    "push",
    "emit",
    "listener",
    "serviceWorkerUpdatingSetter",
    "worker",
    "console",
    "log",
    "sendMessageToServiceWorkerUpdate",
    "shouldBecomeNavigatorController",
    "controller",
    "navigatorWillReload",
    "autoReloadEnabled",
    "registration",
    "update",
    "updateRegistration",
    "installing",
    "waiting",
    "warn",
    "message",
    "objectWithPostMessage",
    "MessageChannel",
    "port1",
    "port2",
    "onmessage",
    "data",
    "postMessage",
    "sendMessageUsingChannel",
    "sendSkipWaitingToWorker",
    "params",
    "Error",
    "onActivating",
    "onActivated",
    "onBecomesNavigatorController",
    "waitUntilActivated",
    "removeStateChangeListener",
    "removeControllerChangeListener",
    "reload",
    "refreshing",
    "location",
    "loadImage",
    "crossOrigin",
    "image",
    "Image",
    "errored",
    "error",
    "unbindEvents",
    "srcElement",
    "onerror",
    "onabort",
    "src",
    "recover",
    "preloadImages",
    "images",
    "chunkSize",
    "msDelayBetweenChunks",
    "index",
    "loaded",
    "failed",
    "preloadChunk",
    "chunk",
    "all",
    "map",
    "setTimeout",
    "nextChunk",
    "getNextChunk",
    "woodUrl",
    "URL",
    "System",
    "import",
    "pirateHookUrl",
    "pirateHook2Url",
    "woodBoxUrl",
    "treasureMapUrl",
    "witchLabelUrl",
    "skullBottleUrl",
    "Preloader",
    "scope",
    "unregistered",
    "unregister",
    "removeUpdateFoundListener",
    "register",
    "active",
    "registerServiceWorker",
    "ImagePreloader",
    "cardDefaultUrl",
    "cardImageUrlMap",
    "timeoutId",
    "clearTimeout",
    "assign",
    "cache",
    "Status",
    "useImage",
    "cachedImg",
    "setStatus",
    "mounted",
    "useRef",
    "current",
    "OnceIntersectingSuspense",
    "fallback",
    "root",
    "rootMargin",
    "threshold",
    "isIntersecting",
    "isIntersectingSetter",
    "nodeSetter",
    "observer",
    "IntersectionObserver",
    "unobserve",
    "observe",
    "disconnect",
    "ref",
    "loadWhenIntersecting",
    "usePlaceholderWhileLoading",
    "animateLoaded",
    "intersectionRoot",
    "intersectionRootMargin",
    "intersectionThreshold",
    "FallbackWhileNotIntersecting",
    "ImageNotIntersectingFallback",
    "FallbackWhileLoading",
    "ImageLoadingFallback",
    "useImageStatusHook",
    "imageFetchEnd",
    "Component",
    "AnimateImageLoaded",
    "imageProps",
    "ComponentPrevious",
    "OnceImageLoadedSuspense",
    "mountedRef",
    "nodeRef",
    "statusRef",
    "useLayoutEffect",
    "statusPrevious",
    "opacity",
    "animate",
    "duration",
    "forwardRef",
    "TRANSPARENT_PNG_DATA_URL",
    "loadscreenCssUrl",
    "_empty",
    "LoadScreen",
    "urlLoadingState",
    "loadscreenRef",
    "loadscreenUrlTrackerReady",
    "loadscreenUrlsLoaded",
    "loadscreenUrlsLoadedSetter",
    "mainImportLoading",
    "mainImportLoadingSetter",
    "mainImportNamespace",
    "mainImportNamespaceSetter",
    "mainUrlTrackerReady",
    "mainUrlTrackerReadySetter",
    "mainUrlsLoaded",
    "mainsUrlsLoadedSetter",
    "mainUrlErrorSetter",
    "urlTrackerTotalCount",
    "urlTrackerLoadedCount",
    "filter",
    "useUrlTrackerLoadedCount",
    "splashscreen",
    "remove",
    "module",
    "namespace",
    "fill",
    "onfinish",
    "style",
    "display",
    "App",
    "id",
    "symbolSkullUrl",
    "className",
    "LowerLevelComponent",
    "ComponentDisplayedOnError",
    "Main",
    "maxWidth",
    "margin",
    "overflow",
    "stack",
    "subClass",
    "superClass",
    "TypeError",
    "create",
    "Constructor",
    "protoProps",
    "staticProps",
    "instance",
    "hasError"
  ],
  "mappings": "uLAAO,IC2BqBA,EACpBC,EAEAC,ED9BKC,EAAsBC,OAAOC,oBACtC,SAACC,OACOC,EAAYH,OAAOC,oBAAoBC,EAAU,CAAEE,QAAS,aAC3D,WACLJ,OAAOK,mBAAmBF,KAG9B,SAACD,OACOC,EAAYH,OAAOM,sBAAsBJ,UACxC,WACLF,OAAOO,qBAAqBJ,uBERpBK,EAAQC,MACP,OAAXD,EAAiB,MAAO,OAGxBE,EACAC,EAFAC,WCLUJ,EAAQC,MACP,OAAXD,EAAiB,MAAO,OAGxBE,EACAC,EAHAC,EAAS,GACTC,EAAaC,OAAOC,KAAKP,OAGxBG,EAAI,EAAGA,EAAIE,EAAWG,OAAQL,IACjCD,EAAMG,EAAWF,GACbF,EAASQ,QAAQP,IAAQ,IAC7BE,EAAOF,GAAOF,EAAOE,WAEhBE,EDNMM,CAA6BV,EAAQC,MAG9CK,OAAOK,sBAAuB,KAC5BC,EAAmBN,OAAOK,sBAAsBX,OAC/CG,EAAI,EAAGA,EAAIS,EAAiBJ,OAAQL,IACvCD,EAAMU,EAAiBT,GACnBF,EAASQ,QAAQP,IAAQ,GACxBI,OAAOO,UAAUC,qBAAqBC,KAAKf,EAAQE,KACxDE,EAAOF,GAAOF,EAAOE,WAGlBE,KEfIY,SAAsB,SAACC,EAASC,EAAWxB,EAAUyB,UAChEF,EAAQG,iBAAiBF,EAAWxB,EAAUyB,GACvC,WACLF,EAAQI,oBAAoBH,EAAWxB,EAAUyB,OAOxCG,EAAkB,SAACC,UAAMA,EAAE/B,SAAW+B,GAEtCC,EAAoB,SAACD,UAAqB,IAAfA,EAAEE,UA+C7BC,UA3Cc,SAACC,MAEJ,IAAlBA,EAAKF,gBACA,MAEHG,EAAWD,EAAKC,SAASC,oBAEd,UAAbD,EACgB,WAAdD,EAAKG,MAGFJ,EAAUC,GAGf,CAAC,SAAU,SAAU,WAAY,SAAU,YAAYlB,QAAQmB,IAAa,GAI5ED,EAAKI,aAAa,aAAeJ,EAAKI,aAAa,aAInDJ,EAAKI,aAAa,aAPbL,EAAUC,GAWf,CAAC,IAAK,QAAQlB,QAAQmB,IAAa,GACH,IAA9BD,EAAKI,aAAa,SAGfL,EAAUC,GAGf,CAAC,QAAS,SAASlB,QAAQmB,IAAa,KACJ,IAAlCD,EAAKI,aAAa,aAGfL,EAAUC,OAMI,SAACA,MACpBK,EAAkBL,UACb,KAEiC,WAAtCM,EAAcN,EAAM,qBACf,UAGLO,EAAiBP,EACdO,IACDF,EAAkBE,IADD,IAI4B,SAA7CD,EAAcC,EAAgB,kBACzB,EAETA,EAAiBA,EAAeC,kBAG3B,IAIIH,SAAoB,SAACL,UAASA,IAASA,EAAKS,cAAcC,mBAI1DJ,SAAgB,SAACK,EAASC,UAFf,SAACD,UAAYE,EAAqBF,GAASG,iBAAiBH,GAEpCI,CAASJ,GAASK,iBAAiBJ,MAUtEC,EAAuB,SAACF,UAC/BhB,EAAgBgB,GAAiBA,EAEjCd,EAAkBc,GAAiBA,EAAQM,YAExCC,EAAuBP,GAASM,aAW5BC,EAAyB,SAACP,UACjChB,EAAgBgB,GAAiBA,EAAQQ,SAEzCtB,EAAkBc,GAAiBA,EAEhCA,EAAQF,eCpHXW,UDuH2B,SAACT,OAC1BU,EAAgBR,EAAqBF,GACrCW,EAAkBJ,EAAuBP,SACxC,CACLY,EAAGF,EAAcG,aAAeF,EAAgBZ,gBAAgBe,WAChEC,EAAGL,EAAcM,aAAeL,EAAgBZ,gBAAgBkB,cC5H1CC,EAAMC,iBAC1BC,EAAU,SAACC,EAAOC,UAAWA,EAAOD,IACpCE,EAAe,GAIRC,EAAqB,gBAAGC,IAAAA,gBAEjCP,gBAACT,EAAkBiB,UAASC,MAAOT,EAAMU,WAAWR,EAASG,IAC1DE,IAyBMI,EAAwB,SAACC,OAC9BC,EAAeb,EAAMc,WAAWvB,OACjCsB,QAII,CAAC,aAAU,kBAGdE,EAAWF,EAAa,GAkBxBG,EAAa,WACjBD,GAAS,SAACZ,OACHA,EAAMc,eAAeL,UACjBT,KAIM,YADAA,EAAMS,GAAKM,cAEjBf,MAGHgB,EAAkB,UACxBrE,OAAOC,KAAKoD,GAAOiB,SAAQ,SAAC1E,GACtBA,IAAQkE,IACVO,EAAgBzE,GAAOyD,EAAMzD,OAI1ByE,aAoBXnB,EAAMqB,WAAU,kBArDdN,GAAS,SAACZ,UACJS,KAAOT,EAEFA,SAMJA,WACFS,EAAM,CAAEM,OAAQ,gBA6Cd,WACLF,OAED,IAEI,CAvBU,WACfD,GAAS,SAACZ,UACJS,KAAOT,GAA+B,WAAtBA,EAAMS,GAAKM,OAEtBf,SAMJA,WACFS,EAAM,CAAEM,OAAQ,gBAYLF,IAmBdM,EAAqB,eACnBT,EAAeb,EAAMc,WAAWvB,UACjCsB,EAMEA,EAAa,GAFX,MAOEU,EAAoB,SAAC9D,EAASvB,OACnCsF,EAAqBhE,EAAoBC,EAAS,QAAQ,WAC9DgE,IACAvF,OAEIuF,EAAsBjE,EAAoBC,EAAS,SAAS,WAChE+D,IACAtF,cAGK,WACLsF,IACAC,MJxISC,SAAa,gBAAGC,IAAAA,OACRhB,EAAsBgB,GAAlCC,mBAEP5B,EAAMqB,WAAU,kBACPQ,EAA6BF,EAAM,CAAEG,OAAQF,MACnD,CAACD,IAEG,QA2CHE,GAxCsBjG,EAwC4B,SAAC+F,gEAA8B,OAAtBG,OAAAA,aAAS,eAClEC,EAAOzC,SAAS0C,cAAc,QACpCD,EAAKE,IAAM,aACXF,EAAKzD,KAAO,eACN4D,EAAuBX,EAAkBQ,EAAMD,UACrDC,EAAKJ,KAAOA,EACZrC,SAAS6C,KAAKC,YAAYL,GACnB,WACLG,IACA5C,SAAS6C,KAAKE,YAAYN,KAhDtBlG,EAAU,IAAIyG,IAEdxG,EAAY,SAAC6F,MACZ9F,EAAQ0G,IAAIZ,UAIa9F,EAAQ2G,IAAIb,GAAlCc,IAAAA,SAAaC,oBACjBD,EAAW,EACb5G,EAAQ8G,IAAIhB,KACVc,SAAUA,EAAW,GAClBC,KAKP7G,EAAQ+G,OAAOjB,GACfe,EAAKG,iBAGA,SAAClB,MACF9F,EAAQ0G,IAAIZ,GAAO,OACS9F,EAAQ2G,IAAIb,GAAlCc,IAAAA,SAAaC,2BACrB7G,EAAQ8G,IAAIhB,KACVc,SAAUA,EAAW,GAClBC,IAEE5G,6BAPMgH,mCAAAA,wBAUTD,EAAcjH,gBAAG+F,UAASmB,WAChCjH,EAAQ8G,IAAIhB,EAAM,CAChBc,SAAU,EACVI,YAAAA,IAEK/G,IKzDX,SAASiH,EAAiBnG,EAAQoG,OAC3B,IAAIrG,EAAI,EAAGA,EAAIqG,EAAMhG,OAAQL,IAAK,KACjCsG,EAAaD,EAAMrG,GACvBsG,EAAWC,WAAaD,EAAWC,aAAc,EACjDD,EAAWE,cAAe,EACtB,UAAWF,IAAYA,EAAWG,UAAW,GACjDtG,OAAOuG,eAAezG,EAAQqG,EAAWvG,IAAKuG,UCZnCnG,OAAOwG,gBACnB,SAACC,EAAGC,UAEHD,EAAEE,UAAYD,EACPD,KCJIzG,OAAOwG,eAClBxG,OAAO4G,eAEP,SAACH,UAAMA,EAAEE,WAAa3G,OAAO4G,eAAeH,mBCDhCI,EAAMpG,UAChBA,GAAyB,WAAhBqG,EAAOrG,IAAqC,mBAATA,WCHlCoG,WAED,IAATA,QACI,IAAIE,eAAe,oEAEpBF,EDCAG,CAAsBH,GAFpBpG,GEAI,SAASwG,EAAaC,OAC/BC,ECLS,cACU,oBAAZC,UAA4BA,QAAQC,UAAW,OAAO,KAE7DD,QAAQC,UAAUC,KAAM,OAAO,KAId,mBAAVC,MAAsB,OAAO,aAQtCC,KAAKjH,UAAUkH,SAAShH,KAAK2G,QAAQC,UAAUG,KAAM,IAAI,iBAClD,EACP,MAAOE,UACA,GDbuBC,UAEzB,eAEDC,EADAC,EAAQjB,EAAeM,MAEvBC,EAA2B,KAEzBW,EAAYlB,EAAemB,MAAMC,YAErCJ,EAASR,QAAQC,UAAUQ,EAAOI,UAAWH,QAG7CF,EAASC,EAAMK,MAAMH,KAAME,kBAEtBE,EAA0BJ,KAAMH,IEjBpC,ICCMQ,EAAc,iBACMlF,EAAMmF,UAAS,YAAvCC,OAAQC,cACfrF,EAAMqB,WAAU,kBACPtF,GAAoB,WACzBsJ,GAAa,QAEd,IACID,GCVIE,SAAc,SAACC,EAAwBC,EAAOtJ,UACzDqJ,EAAuB3H,iBAAiB4H,EAAOtJ,GACxC,WACLqJ,EAAuB1H,oBAAoB2H,EAAOtJ,OCiF/C,SAASuJ,EAAOhF,EAAOiF,EAAMC,UAC/BA,EACID,EAAOA,EAAKjF,GAASA,GAExBA,GAAUA,EAAMiF,OACpBjF,EAAQmF,QAAQC,QAAQpF,IAElBiF,EAAOjF,EAAMiF,KAAKA,GAAQjF,GArFlC,IAAMqF,EAAmB9J,OAAO+J,UAAUC,cAgEnC,WAAgBC,UACf,eACD,IAAInD,EAAO,GAAInG,EAAI,EAAGA,EAAIoI,UAAU/H,OAAQL,IAChDmG,EAAKnG,GAAKoI,UAAUpI,cAGbiJ,QAAQC,QAAQI,EAAEjB,MAAMH,KAAM/B,IACpC,MAAM0B,UACAoB,QAAQM,OAAO1B,KAiclB,WAAe2B,EAAMT,EAAMC,MAC7BA,SACID,EAAOA,EAAKS,KAAUA,YAGzBzB,EAASkB,QAAQC,QAAQM,YACtBT,EAAOhB,EAAOgB,KAAKA,GAAQhB,EACjC,MAAOF,UACDoB,QAAQM,OAAO1B,IAUjB,WAAiB2B,EAAMT,OACzBhB,EAASyB,WACTzB,GAAUA,EAAOgB,KACbhB,EAAOgB,KAAKA,GAEbA,EAAKhB,GA9hBN,ICPD0B,EDOOC,EAAsBC,QAAQR,GAGvCS,EAAsB,KAMtBC,EAAwB,KACtBC,GCjBAL,EAAY,GA2CT,CACLM,OA1Ca,SAACxK,gEAA6B,OAAjByK,KAAAA,mBACtBA,EAAM,KACFC,EAAmB1K,EACzBA,EAAW,WACT2K,IACAD,2BAIJR,cAAgBA,IAAWlK,QAEvB4K,GAAU,EACRD,EAAgB,eAChBC,GACJA,GAAU,UACJC,EAA2B,GAC7BpK,EAAIyJ,EAAUpJ,OACdgK,GAAY,EACTrK,KAAK,KACJsK,EAAoBb,EAAUzJ,GAChCqK,GACEC,IAAsB/K,EACxB8K,GAAY,EAKdD,EAAyBG,KAAKD,GAGlCb,EAAYW,WAEPF,GAWPM,KARW,sCAAIrE,2BAAAA,kBACfsD,EAAUhF,SAAQ,SAACgG,GACjBA,eAAYtE,SDrBZuE,EAA8B,SAACC,GAC/Bd,GAAyBA,IAA0Bc,EAKrDC,QAAQC,IAAI,4CAGVF,EACFC,QAAQC,wDAAiDF,EAAOnH,YAEhEoH,QAAQC,6BAEVhB,EAAwBc,EACxBb,EAAkCU,SAuHvBM,UApH2B,kBAAMnB,QAAQC,aA4EhB,kBAC7BC,EACH,CACEkB,gCAAiCpB,QAAQR,EAAiB6B,YAC1DC,oBAAqBC,GAEvB,eAGmC,SAAC3L,UACjCuK,EAAkCC,OAAOxK,iCAI3CqK,IAKsBA,YAArBuB,YAC2BA,EAAaC,mBAAxCC,OAEEC,EAAeD,EAAfC,cACJA,SACFV,QAAQC,IAAI,kDACZH,EAA4BY,IACrB,MAGDC,EAAYF,EAAZE,eACJA,GACFX,QAAQC,IAAI,+CACZH,EAA4Ba,IACrB,IAGTX,QAAQC,IAAI,2CACL,UAtBLD,QAAQY,0FACD,OAwBqC,SAACC,MAC1C5B,SEzJgC,SAAC6B,EAAuBD,SACpC,IAAIE,eAArBC,IAAAA,MAAOC,IAAAA,aACR,IAAI5C,SAAQ,SAACC,EAASK,GAC3BqC,EAAME,UAAY,SAAUjD,GACA,aAAtBA,EAAMkD,KAAKxH,OACbgF,EAAOV,EAAMkD,KAAKjI,OAElBoF,EAAQL,EAAMkD,KAAKjI,QAGvB4H,EAAsBM,YAAYP,EAAS,CAACI,OFmJvCI,CAAwBpC,EAAuB4B,GAHpDb,QAAQY,wDAaNU,qBAP4CC,OAC3CtC,QACG,IAAIuC,MAAM,+CAEXF,EAAwBrC,EAAuBsC,mBAItDxB,qEAC+F,OAA7F0B,aAAAA,aAAe,mBAAUC,YAAAA,aAAc,mBAAUC,6BAAAA,aAA+B,eAE1E/I,EAAUmH,EAAVnH,MACFgJ,EAAqB,kBAClB,IAAIvD,SAAQ,SAACC,OACZuD,EAA4B9D,EAAYgC,EAAQ,eAAe,WAC9C,eAAjBA,EAAOnH,OAET6I,IAEmB,cAAjB1B,EAAOnH,QAET8I,IACAG,IACAvD,oCAWM,cAAV1F,GAAmC,eAAVA,QACb,cAAVA,GACFsH,EAAiC,CAAErH,OAAQ,kBAKvC+I,iBAEFrD,EAAiB6B,eACb0B,EAAiC/D,EACrCQ,EACA,oBACA,WACEuD,IACAH,IACA7B,EAA4B,MACLiC,aAI3BjC,EAA4B,MACLiC,0CAM3BJ,IACA7B,EAA4B,MACLiC,YAGrBzB,GAAoB,EAKpB0B,IAAa,EACXD,GAAS,WACTC,KAGJA,IAAa,EACbvN,OAAOwN,SAASF,WAGlB,GAAIjD,EACqCf,EAAYQ,EAAkB,mBAAoBwD,IGlPpF,IAAMG,GAAY,SAAC7I,EAAK8I,OACvBC,EAAQ,IAAIC,aAEdF,IACFC,EAAMD,YAAcA,GAGf,IAAI9D,SAAQ,SAACC,EAASK,OAUrB2D,EAAU,SAACC,GAEfC,GAAaJ,GAEbzD,EAAO4D,IAITH,EAAM7H,OAhBS,SAAC0D,GAEduE,GAAaJ,GAEb9D,EAAQL,EAAM5I,QAAU4I,EAAMwE,aAahCL,EAAMM,QAAUJ,EAChBF,EAAMO,QAAUL,EAGhBF,EAAMQ,IAAMvJ,MAIVmJ,GAAe,SAACJ,GAEpBA,EAAM7H,OAAS,KACf6H,EAAMM,QAAU,KAChBN,EAAMO,QAAU,gBAKPP,EAAMQ,IACb,MAAO3F,MCuCJ,YAAgB/D,EAAOiF,EAAMC,UAC/BA,EACID,EAAOA,EAAKjF,GAASA,GAExBA,GAAUA,EAAMiF,OACpBjF,EAAQmF,QAAQC,QAAQpF,IAElBiF,EAAOjF,EAAMiF,KAAKA,GAAQjF,GArB3B,YAAgBwF,UACf,eACD,IAAInD,EAAO,GAAInG,EAAI,EAAGA,EAAIoI,UAAU/H,OAAQL,IAChDmG,EAAKnG,GAAKoI,UAAUpI,cAGbiJ,QAAQC,QAAQI,EAAEjB,MAAMH,KAAM/B,IACpC,MAAM0B,UACAoB,QAAQM,OAAO1B,KAkhBlB,eAjgBA,YAAuB/D,EAAOkF,OAC/BA,SACGlF,GAASA,EAAMiF,KAAOjF,EAAMiF,SAAeE,QAAQC,UAycrD,YAAwBM,OAC1BzB,EAASyB,OACTzB,GAAUA,EAAOgB,YACbhB,EAAOgB,SAKT,YAAgBS,EAAMiE,WAEvB1F,EAASyB,IACZ,MAAM3B,UACA4F,EAAQ5F,UAEZE,GAAUA,EAAOgB,KACbhB,EAAOgB,UAAK,EAAQ0E,GAErB1F,EAhdD,YAA0BjE,MAC5BA,GAASA,EAAMiF,YACXjF,EAAMiF,SA3GR,IAAM2E,gBACXC,gEACiD,OAA/CC,UAAAA,aAAY,QAAGC,qBAAAA,aAAuB,MAEpCC,EAAQ,EACNC,EAAS,GACTC,EAAS,GAETC,eAAsBC,aACpBjF,QAAQkF,IACZD,EAAME,iBAAWZ,sCAEOV,GAAUU,aAAxBR,GACNe,EAAOP,GAAOR,mBAEdgB,EAAOR,IAAO,iCAId,IAAIvE,SAAQ,SAACC,GACjBmF,WAAWnF,EAAS2E,sBAEhBS,EAAYC,6BACdD,EAAUjO,OAAS,YACf4N,EAAaK,gBAIjBC,EAAe,mBACbL,EAAQ,GACVlO,EAAI,EACDA,EAAI4N,GAAaE,EAAQH,EAAOtN,QACrC6N,EAAM3D,KAAKoD,EAAOG,IAClB9N,IACA8N,WAEKI,aAGHD,EAAaM,uBAEZ,CAAER,OAAAA,EAAQC,OAAAA,SCnCbQ,GAAU,IAAIC,IAAIC,+CAAiBC,YACnCC,GAAgB,IAAIH,IAAIC,sDAA8BC,YACtDE,GAAiB,IAAIJ,IAAIC,yDAAiCC,YAC1DG,GAAa,IAAIL,IAAIC,mDAA2BC,YAChDI,GAAiB,IAAIN,IAAIC,uDAAsCC,YAC/DK,GAAgB,IAAIP,IAAIC,sDAAqCC,YAC7DM,GAAiB,IAAIR,IAAIC,uDAAsCC,YAExDO,GAAY,eACjBzG,EAASF,WAEflF,EAAMqB,WAAU,WACV+D,GLmB6B,SAACxE,OAAOkL,0DAAU,IAAVA,UACtCzF,SACI,iBAGL0F,GAAe,EACfC,EAAa,aACbC,EAA4B,eAEhC1F,EAAsBT,EAAiBoG,SAAStL,EAAK,CAAEkL,MAAAA,cAE/ChE,MACNkE,EAAa,WACXlE,EAAakE,cAGXD,EACFC,aAIM/D,EAAgCH,EAAhCG,WAAgCH,EAApBI,QAAoBJ,EAAXqE,OAE7BF,EAA4B3G,EAAYwC,EAAc,eAAe,WACnEP,QAAQC,IAAI,gDACRM,EAAaG,aAAeA,EAIhCZ,EAA4BS,EAAaG,YAHvCV,QAAQC,0EK5CV4E,CAAsB,wBAEvB,CAAChH,IAEGA,EAASpF,gBAACqM,SAAoB,MAGjCA,GAAiB,eACf/B,GACJa,GACAI,GACAC,GACAC,GACAC,GACAC,GACAC,GACAU,YACGxP,OAAOC,KAAKwP,GAAiBxB,KAAI,SAACrO,UAAQ6P,EAAgB7P,eAG/DsD,EAAMqB,WAAU,eACRmL,EAAYxB,YAAW,kBAAMX,GAAcC,KAAS,YACnD,WACLmC,aAAaD,MAEd,IAEI,mBCnCM1P,OAAO4P,QAbtB,SAAgB9P,OACT,IAAID,EAAI,EAAGA,EAAIoI,UAAU/H,OAAQL,IAAK,KAErCH,EAASuI,UAAUpI,OAClB,IAAID,KAAOF,EACVM,OAAOO,UAAU4D,eAAe1D,KAAKf,EAAQE,KAC/CE,EAAOF,GAAOF,EAAOE,WAIpBE,ICPT,IAAM+P,GAAQ,IAAIrK,IAEX,IAAMsK,GACF,UADEA,GAEH,SAFGA,GAGH,SAGGC,GAAW,SAAC1C,OACjB2C,EAAYH,GAAMnK,IAAI2H,GACtB9J,EAAeyM,EAAYF,GAAgBA,KACrB5M,EAAMmF,SAAS9E,YAApCa,OAAQ6L,OACTC,EAAUhN,EAAMiN,QAAO,UAE7BjN,EAAMqB,WAAU,kBACT8I,GAAOjJ,IAAW0L,IAGvBI,EAAQE,SAAU,GAiDCjH,oBA4ehB,SAAgBE,EAAMiE,WAEvB1F,EAASyB,IACZ,MAAM3B,UACA4F,EAAQ5F,UAEZE,GAAUA,EAAOgB,KACbhB,EAAOgB,UAAK,EAAQ0E,GAErB1F,sBAveejE,EA5DKgJ,GAAUU,GA4DRzE,WA5DhBiE,GACDqD,EAAQE,UAEbP,GAAMhK,IAAIwH,EAAKR,GACfoD,EAAUH,MAyDbjH,EACID,EAAOA,EAAKjF,GAASA,GAExBA,GAAUA,EAAMiF,OACpBjF,EAAQmF,QAAQC,QAAQpF,IAElBiF,EAAOjF,EAAMiF,KAAKA,GAAQjF,GAP3B,IAAgBA,EAAOiF,EAAMC,gBAtDvBqH,EAAQE,UAEbP,GAAM/J,OAAOuH,GACb4C,EAAUH,SAsCV,eACD,IAAI9J,EAAO,GAAInG,EAAI,EAAGA,EAAIoI,UAAU/H,OAAQL,IAChDmG,EAAKnG,GAAKoI,UAAUpI,cAGbiJ,QAAQC,QAAQI,EAAEjB,MAAMH,KAAM/B,IACpC,MAAM0B,UACAoB,QAAQM,OAAO1B,QAzCd,WACLwI,EAAQE,SAAU,IAnBX,aAmDN,IAAgBjH,IA9BlB,CAACkE,EAAKjJ,IAEF,CAACA,EAAQ4L,ICxCLK,GAA2B,gBACtCC,IAAAA,SACAC,IAAAA,KACAC,IAAAA,eACAC,UAAAA,aAAY,IACZhN,IAAAA,WAE+CP,EAAMmF,UAAS,YAAvDqI,OAAgBC,SACIzN,EAAMmF,SAAS,eAAnChH,OAAMuP,cAEb1N,EAAMqB,WAAU,eACTlD,SACI,gBAELqP,SACK,iBAIHG,EAAW,IAAI3R,OAAO4R,sBAC1B,sBACYJ,gBACRG,EAASE,UAAU1P,GACnBsP,GAAqB,IAErBA,GAAqB,KAGzB,CACEJ,KAAAA,EACAC,WAAAA,EACAC,UAAAA,WAGJI,EAASG,QAAQ3P,GAEV,WACLwP,EAASI,gBAEV,CAAC5P,EAAMqP,IAELA,EAIExN,gCAAGO,GAHD6M,EAAS,CAAEY,IAAKN,KCtCd9D,UAAQ,oBACnBqE,qBAAAA,oBACAC,2BAAAA,oBACAC,cAAAA,gBAEAC,IAAAA,iBACAC,IAAAA,uBACAC,IAAAA,0BACAC,6BAAAA,aAA+BC,SAC/BC,qBAAAA,aAAuBC,SACvBC,mBAAAA,aAAqB9B,KAErB1C,IAAAA,IACGnH,oOAEc2L,EAAmBxE,GAA7BjJ,cACiBP,EAAsBwJ,GAAvCyE,YACP5O,EAAMqB,WAAU,WACC,WAAXH,GACF0N,MAED,CAAC1N,QAEA2N,EAAY7O,0BAAKmK,IAAKA,GAASnH,OAE/BmL,IACFU,EAAY7O,gBAAC8O,IAAmB5N,OAAQA,EAAQiJ,IAAKA,EAAK4E,WAAY/L,KAGpEkL,GAAyC,WAAXhN,EAAqB,KAC/C8N,EAAoBH,EAC1BA,EACE7O,gBAACiP,IAAwB/N,OAAQA,EAAQkM,SAAUpN,gBAACyO,EAAyBzL,IAC1EgM,MAKHf,GAAmC,WAAX/M,EAAqB,KACzC8N,EAAoBH,EAC1BA,EACE7O,gBAACmN,IACCC,SAAU,gBAAGY,IAAAA,WAAUhO,gBAACuO,MAA6BP,IAAKA,GAAShL,KACnEqK,KAAMe,EACNd,WAAYe,EACZd,UAAWe,GAEVU,UAKAH,KAGHC,GAAqB,gBAAG5N,IAAAA,OAAQiJ,IAAAA,IAAK4E,IAAAA,WACnCG,EAAalP,EAAMiN,QAAO,GAC1BkC,EAAUnP,EAAMiN,SAChBmC,EAAYpP,EAAMiN,OAAO/L,UAE/BlB,EAAMqP,iBAAgB,eACdrC,EAAUkC,EAAWhC,QACrB/O,EAAOgR,EAAQjC,QACfoC,EAAiBF,EAAUlC,WACjCgC,EAAWhC,SAAU,EACrBkC,EAAUlC,QAAUhM,EAMhB8L,GAAWsC,IAAmBpO,GAAqB,WAAXA,EAAqB,KACzDqO,EAAUvT,OAAOiD,iBAAiBd,GAAMgB,iBAAiB,WAC/DhB,EAAKqR,QAAQ,CAAC,CAAED,QAAS,GAAK,CAAEA,QAAAA,IAAY,CAC1CE,SAAU,SAGb,CAACvO,EAAQiO,IAELnP,0BAAKgO,IAAKmB,EAAShF,IAAKA,GAAS4E,KAGpCE,GAA0B,gBAAG7B,IAAAA,SAAUlM,IAAAA,OAAQX,IAAAA,eACpC,WAAXW,EACKkM,EAEF7M,GAIHmO,GAAuB1O,EAAM0P,YAAW,SAAC1M,EAAOgL,UAC7ChO,0BAAKmK,IAAKwF,GAA0B3B,IAAKA,GAAShL,OAIrDwL,GAA+BxO,EAAM0P,YAAW,SAAC1M,EAAOgL,UACrDhO,0BAAKmK,IAAKwF,GAA0B3B,IAAKA,GAAShL,OAGrD2M,GACJ,qHC3FF,IAAMC,GAAmB,IAAIxE,IAAIC,qDAAqBC,YAilB/C,SAASuE,MAvkBhB,IAAMC,GAAa,SAAC9M,OrBPZ+M,EqBQAC,EAAgBhQ,EAAMiN,SACtBgD,EAA4B/K,MACyBlF,EAAMmF,UAAS,YAAnE+K,OAAsBC,SAGwBnQ,EAAMmF,UAAS,YAA7DiL,OAAmBC,SAC+BrQ,EAAMmF,SAAS,eAAjEmL,OAAqBC,SAC6BvQ,EAAMmF,UAAS,YAAjEqL,OAAqBC,SACoBzQ,EAAMmF,UAAS,YAAxDuL,OAAgBC,SACQ3Q,EAAMmF,WAA5ByL,YAEHC,GrBnBAd,EAAkBzO,IACLxE,OAAOC,KAAKgT,GAAiB/S,QqBmB1C8T,ErBfgC,eAChCf,EAAkBzO,WACJxE,OAAOC,KAAKgT,GAAiBgB,QAC/C,SAACnQ,SAAwC,WAAhCmP,EAAgBnP,GAAKM,UAC9BlE,OqBW4BgU,UAE9BhR,EAAMqB,WAAU,WACV4O,GAA6Ba,IAA0BD,GACzDV,GAA2B,KAE5B,CAACF,EAA2Ba,EAAuBD,IAEtD7Q,EAAMqB,WAAU,WAwBX,IAAgB4E,EAvBdiK,IAILlU,OAAOiV,aAAaC,SAEpBb,GAAwB,IAiBLpK,oBAqChB,SAA0BxF,MAC5BA,GAASA,EAAMiF,YACXjF,EAAMiF,KAAKmK,KAqcb,SAAgB1J,EAAMiE,WAEvB1F,EAASyB,IACZ,MAAM3B,UACA4F,EAAQ5F,UAEZE,GAAUA,EAAOgB,KACbhB,EAAOgB,UAAK,EAAQ0E,GAErB1F,sBAveejE,EA5BS0Q,SAAO,YA4BTzL,WA5BhB0L,GACNf,GAAwB,GACxBE,EAA0Ba,GAC1BrV,GAAoB,WAClB0U,GAA0B,OAyB/B9K,EACID,EAAOA,EAAKjF,GAASA,GAExBA,GAAUA,EAAMiF,OACpBjF,EAAQmF,QAAQC,QAAQpF,IAElBiF,EAAOjF,EAAMiF,KAAKA,GAAQjF,GAP3B,IAAgBA,EAAOiF,EAAMC,cAtBrBnB,GAEPoM,GAAmB,iBACXpM,UAMR,eACD,IAAI1B,EAAO,GAAInG,EAAI,EAAGA,EAAIoI,UAAU/H,OAAQL,IAChDmG,EAAKnG,GAAKoI,UAAUpI,cAGbiJ,QAAQC,QAAQI,EAAEjB,MAAMH,KAAM/B,IACpC,MAAM0B,UACAoB,QAAQM,OAAO1B,WATpB,CAAC0L,IAEJlQ,EAAMqB,WAAU,WACVmP,GAAuBM,IAA0BD,GACnDF,GAAsB,KAEvB,CAACH,EAAqBM,EAAuBD,IAEhD7Q,EAAMqB,WAAU,WACVqP,GAAkBV,IACFA,EAAc9C,QAAQsC,QAAQ,CAAC,CAAED,QAAS,GAAK,CAAEA,QAAS,IAAM,CAChFE,SAAU,IACV4B,KAAM,aAEEC,SAAW,WACnBtB,EAAc9C,QAAQqE,MAAMC,QAAU,WAGzC,CAACxB,EAAeU,IAGjB1Q,gCACGsQ,EAAsBtQ,gBAACsQ,EAAoBmB,IAAQzO,GAAY,KAChEhD,uBAAK0R,GAAG,aAAa1D,IAAKgC,GACxBhQ,gBAAC0B,GAAWC,KAAMiO,KAClB5P,gBAAC4J,IAAMO,IAAKwH,EAAgBxD,eAAe,IAC1CiC,EACCpQ,qBAAG4R,UAAU,gCAEb5R,gCACEA,qBAAG4R,UAAU,gCACb5R,uBAAK4R,UAAU,YACZd,MAAwBD,KAKhCH,EAAiB1Q,gBAAC6L,SAAe,OAiBjC,IbzHoBgG,GAAqBC,GayHnCC,IbzHcF,GaeX,SAAC7O,UAEbhD,gBAACM,OACCN,gBAAC8P,GAAe9M,KblB0B8O,Ga6G5B,gBAAGhI,IAAAA,aACrB9N,OAAOiV,aAAaC,SAElBlR,uBAAKuR,MAAO,CAAES,SAAU,UACtBhS,uBAAKuR,MAAO,CAAEU,OAAQ,kCACtBjS,uBAAKuR,MAAO,CAAEW,SAAU,OAAQD,OAAQ,cACpB,WAAjBrO,EAAOkG,GAAqBA,EAAMqI,MAAQrI,2BCnHnCsI,EAAUC,MACE,mBAAfA,GAA4C,OAAfA,QAChC,IAAIC,UAAU,sDAEtBF,EAAS/U,UAAYP,OAAOyV,OAAOF,GAAcA,EAAWhV,UAAW,CACrEyH,YAAa,CACXrE,MAAO2R,EACPhP,UAAU,EACVD,cAAc,KAGdkP,GAAY/O,EAAe8O,EAAUC,arBb3BG,EAAaC,EAAYC,oBOIzB1P,yBeJA2P,EAAUH,QAClBG,aAAoBH,SAClB,IAAIF,UAAU,6DfGZtP,IACD7C,MAAQ,CACXyS,UAAU,EACV9I,MAAO,ePRC0I,IAAyBE,kDOYL5I,SACvB,CACL8I,UAAU,EACV9I,MAAAA,OPfqB2I,yCOoBnB5N,KAAK1E,MAAMyS,SACN5S,gBAAC8R,IAA0BhI,MAAOjF,KAAK1E,MAAM2J,QAE/C9J,gBAAC6R,GAAwBhN,KAAK7B,YPtBzBD,EAAiByP,EAAYnV,UAAWoV,GACpDC,GAAa3P,EAAiByP,EAAaE,MOCnB1S,EAAM6O"
}