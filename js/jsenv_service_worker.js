function ownKeys(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,o)}return r}function _objectSpread(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?ownKeys(Object(r),!0).forEach((function(t){_defineProperty(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):ownKeys(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function _defineProperty(e,t,r){return(t=_toPropertyKey(t))in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function _toPropertyKey(e){var t=_toPrimitive(e,"string");return"symbol"==typeof t?t:String(t)}function _toPrimitive(e,t){if("object"!=typeof e||null===e)return e;var r=e[Symbol.toPrimitive];if(void 0!==r){var o=r.call(e,t||"default");if("object"!=typeof o)return o;throw new TypeError("@@toPrimitive must return a primitive value.")}return("string"===t?String:Number)(e)}self.__sw__={};const sw=self.__sw__;{const e={};self.addEventListener("message",(async t=>{const{data:r,ports:o}=t;if("object"!=typeof r)return;const{action:n}=r,s=e[n];if(!s)return;const{payload:a}=r;let c,i;try{const e=await s(a);c="resolved",i=e}catch(e){c="rejected",i=e}o[0].postMessage({actionResultStatus:c,actionResultValue:i})})),sw.registerActions=t=>{Object.assign(e,t)}}sw.init=function(){let{name:e="jsenv",version:t="1",meta:r={},logLevel:o="warn",logBackgroundColor:n="#ffdc00",logColor:s="#000000",resources:a={"/":{}},actions:c={},install:i=(()=>{}),activate:l=(()=>{})}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};if("object"!=typeof a)throw new TypeError(`resources should be an object, got ${a}`);if("string"!=typeof e)throw new TypeError(`name should be a string, got ${e}`);if(0===e.length)throw new TypeError("name must not be empty");if("string"!=typeof o)throw new TypeError(`logLevel should be a boolean, got ${o}`);if("string"!=typeof n)throw new TypeError(`logBackgroundColor should be a string, got ${n}`);if("string"!=typeof s)throw new TypeError(`logColor should be a string, got ${s}`);const u=createCacheName(e),f=u,d=createLogger({logLevel:o,logBackgroundColor:n,logColor:s});a=resolveResources(a),d.info(`init (${f})`),sw.registerActions(_objectSpread({inspect:()=>_objectSpread({name:e,version:t,resources:a},r),refreshCacheKey:async e=>{e=asAbsoluteUrl(e);const t=await self.caches.open(u),r=new Request(e,{cache:"reload"});return fetchAndPutInCache(r,t)},addCacheKey:async e=>{e=asAbsoluteUrl(e);const t=await self.caches.open(u),r=new Request(e);return fetchAndPutInCache(r,t)},removeCacheKey:async e=>{e=asAbsoluteUrl(e);const t=await self.caches.open(u);return await t.delete(e)}},c));{sw.registerActions({skipWaiting:()=>{self.skipWaiting()}}),self.addEventListener("install",(t=>{d.info(`install (${f})`);const r=Promise.all([e(t),i(t)]);t.waitUntil(r)}));const e=async()=>{d.debug("open cache");const e=await self.caches.open(u),t=Object.keys(a),r=t.length;let o=0;await Promise.all(t.map((async t=>{const r=a[t],n=r.versionedUrl?new Request(r.versionedUrl):new Request(t,{cache:"reload"});try{const t=await fetchAndPutInCache(n,e);200===t.status?(d.info(`put "${asRelativeUrl(n.url)}" into cache`),o+=1):d.warn(`cannot put ${n.url} into cache due to response status (${t.status})`)}catch(e){d.warn(`cannot put ${n.url} in cache due to error while fetching: ${e.stack}`)}}))),o===r?d.info(`install done (${r} resources added in cache)`):d.info(`install done (${o}/${r} resources added in cache)`)}}{self.addEventListener("activate",(e=>{d.info(`activate (${f})`);const r=Promise.all([t(e),l(e)]);e.waitUntil(r)})),sw.registerActions({claim:async()=>{await self.clients.claim()},postReloadAfterUpdateToClients:async()=>{(await self.clients.matchAll()).forEach((e=>{e.postMessage("reload_after_update")}))}});const t=async()=>{const t=await self.caches.keys();await Promise.all(t.map((async t=>{t!==u&&t.startsWith(`${e}_`)&&(d.info(`delete old cache "${t}"`),await self.caches.delete(t))})))}}{self.addEventListener("fetch",(t=>{t.waitUntil(e(t))}));const e=async e=>{const r=e.request;if("GET"!==r.method&&"HEAD"!==r.method)return self.fetch(r);let o=!1;if(a[r.url])o=!0;else for(const e of Object.keys(a))if(a[e].versionedUrl===r.url){o=!0;break}if(!o)return self.fetch(r);const n=asRelativeUrl(r.url);if(d.debug(`fetch "${n}" (${f})`),"navigate"===r.mode){const r=e.preloadResponse;if(r){d.debug("preloadResponse available on navigation request, try to use it");const e=await t(r);if(e)return d.info(`${n} -> use preloaded response`),e;d.debug("cannot use preloadResponse")}}try{const t=e.request;d.debug(`open ${u} cache`);const r=await self.caches.open(u);d.debug("search response matching this request in cache");const o=await r.match(t);return o?(d.info(`${n} -> use cache`),o):(d.info(`${n} -> delegate to navigator`),self.fetch(t))}catch(e){return d.warn(`error while trying to use cache for ${n} -> delegate to navigator`,e.stack),self.fetch(r)}},t=async e=>{try{const t=await e;return t&&"error"===t.type?null:t}catch(e){return null}}}};const createCacheName=(()=>{const e=Math.pow(36,4),t=(()=>{const{crypto:e}=self;if(e){const t=Math.pow(2,32)-1;return()=>Math.abs(e.getRandomValues(new Uint32Array(1))[0]/t)}return Math.random})(),r=()=>{return r=(t()*e<<0).toString(36),o=4,(n=`000000000${r}`).substr(n.length-o);var r,o,n};return e=>`${e}_${(new Date).getTime().toString(36)}${`${r()}${r()}`}`})(),createLogger=e=>{let{logLevel:t,logBackgroundColor:r,logColor:o}=e;const n=e=>["%cjsenv%csw","background: orange; color: rgb(55, 7, 7); padding: 1px 3px; margin: 0 1px",`background: ${r}; color: ${o}; padding: 1px 3px; margin: 0 1px`,...e];return{debug:function(){if("debug"===t){for(var e=arguments.length,r=new Array(e),o=0;o<e;o++)r[o]=arguments[o];console.info(...n(r))}},info:function(){if("debug"===t||"info"===t){for(var e=arguments.length,r=new Array(e),o=0;o<e;o++)r[o]=arguments[o];console.info(...n(r))}},warn:function(){if("debug"===t||"info"===t||"warn"===t){for(var e=arguments.length,r=new Array(e),o=0;o<e;o++)r[o]=arguments[o];console.info(...n(r))}},error:function(){if("debug"===t||"info"===t||"warn"===t||"error"===t){for(var e=arguments.length,r=new Array(e),o=0;o<e;o++)r[o]=arguments[o];console.info(...n(r))}},debugGroupCollapsed:function(){if("debug"===t){for(var e=arguments.length,r=new Array(e),o=0;o<e;o++)r[o]=arguments[o];console.groupCollapsed(...n(r))}},infoGroupCollapsed:function(){if("debug"===t||"info"===t){for(var e=arguments.length,r=new Array(e),o=0;o<e;o++)r[o]=arguments[o];console.groupCollapsed(...n(r))}},groupEnd:()=>console.groupEnd()}},asAbsoluteUrl=e=>String(new URL(e,self.location)),asRelativeUrl=e=>e.slice(self.location.origin.length),resolveResources=e=>{const t={};return Object.keys(e).forEach((r=>{const o=e[r],n=asAbsoluteUrl(r);o.versionedUrl&&(o.versionedUrl=asAbsoluteUrl(o.versionedUrl)),t[n]=o})),t},fetchAndPutInCache=async(e,t)=>{const r=await self.fetch(e);if(200===r.status){const o=await asResponseToPutInCache(r);await t.put(e,o)}return r},asResponseToPutInCache=async e=>{const t=e.clone();if(!e.redirected)return t;const r="body"in t?Promise.resolve(t.body):t.blob(),o=await r;return new Response(o,{headers:t.headers,status:t.status,statusText:t.statusText})};