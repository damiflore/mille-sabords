<!DOCTYPE html>
<html>
  <head>
    <title>Score animation</title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="icon" href="../../favicon.png" />
    <script type="importmap" src="../../importmap.dev.importmap"></script>
    <style>
      .dice {
        width: 40px;
        height: 40px;
        background: violet;
      }

      .score-particle {
        position: fixed;
        font-family: Arial;
        font-size: 16px;
        color: gold;
        visibility: hidden;
        /* stroke: red;
        stroke-width: 2px;
        fill: black; */
      }

      .score {
        margin-top: 100px;
        margin-left: 50px;
        border: 1px solid black;
        width: 5em;
      }

      .score--value {
        display: inline-block;
        /* transform-origin: left center; */
      }
    </style>
  </head>

  <body>
    <h1>Score animation</h1>
    <p>
      Cliquer sur le bouton pour afficher une animation qui serq utilisée lorsqu'un élement de ui
      influence le score (un dé par example)
    </p>

    <!-- <svg viewBox="0 0 100 100">
      <text
        x="50"
        y="50"
        text-anchor="middle"
        alignment-baseline="middle"
        style="fill: gold; stroke: black; font-size: 48px"
      >
        100
      </text>
    </svg>

    <svg>
      <text
        text-anchor="middle"
        alignment-baseline="middle"
        style="fill: gold; stroke: black; font-size: 48px"
      >
        1000
      </text>
    </svg> -->

    <div id="app"></div>
    <script type="module">
      import React from "react"
      import ReactDOM from "react-dom"
      import { printPointInDocument, getDomNodeRectangle } from "src/dom/dom.position.js"
      import { getRectangleCenterPoint } from "src/helper/rectangle.js"
      import { useUpdateEffect, useSignalEmitter, useSignalListener } from "src/hooks.js"
      import { useAnimateTransitionUsingJs } from "src/animation/useAnimateTransition.js"

      const debug = false

      const App = () => {
        const domNodeRef = React.useRef()
        const totalScoreDomNodeRef = React.useRef()

        const [totalScore, totalScoreSetter] = React.useState(0)

        const [scoreParticles, addScoreParticle, scoreParticleMergedSignal] = useScoreParticles()

        // score displayed is score without taking into account score into particles
        const totalScoreDisplayed = React.useMemo(() => {
          const scoreInParticles = scoreParticles.reduce(
            (previous, particle) => previous + particle.value,
            0,
          )
          const totalScoreWithoutParticles = totalScore - scoreInParticles
          console.log(
            `totalScoreWithoutParticles updated to ${totalScoreWithoutParticles} (totalScore is ${totalScore})`,
          )
          return totalScoreWithoutParticles
        }, [totalScore, scoreParticles])

        const [diceKept, diceKeptSetter] = React.useState(false)
        const keepCoin = () => {
          diceKeptSetter(true)
        }
        const unkeepCoin = () => {
          diceKeptSetter(false)
        }
        useUpdateEffect(() => {
          if (diceKept) {
            totalScoreSetter((totalScore) => {
              const to = totalScore + 100
              console.log(`dice kept, add 100 to total score -> ${to}`)
              return to
            })
            const removeScoreParticle = addScoreParticle({
              id: "coin-bonus",
              value: 100,
              ...domNodeToScoreParticlePosition(domNodeRef.current),
            })
            return () => {
              console.log("removing coin particle because dice unkept")
              removeScoreParticle()
            }
          }

          totalScoreSetter((totalScore) => {
            const to = totalScore - 100
            console.log(`dice unkept, remove 100 from total score -> ${to}`)
            return to
          })
          return () => {}
        }, [diceKept])

        const [groupOfFour, groupOfFourSetter] = React.useState(false)
        const simulateGroupOfFourFound = () => {
          groupOfFourSetter(true)
        }
        const simulateGroupOfFourLost = () => {
          groupOfFourSetter(false)
        }
        useUpdateEffect(() => {
          if (groupOfFour) {
            const removeScoreParticle = addScoreParticle({
              id: "group-bonus",
              value: 200,
              ...domNodeToScoreParticlePosition(domNodeRef.current),
            })
            totalScoreSetter((totalScore) => {
              const to = totalScore + 200
              console.log(`group of four found, add 200 to total score -> ${to}`)
              return to
            })
            return () => {
              console.log("removing bonus particle because group lost")
              removeScoreParticle()
            }
          }

          totalScoreSetter((totalScore) => {
            const to = totalScore - 200
            console.log(`group of four lost, remove 200 from total score -> ${to}`)
            return to
          })
          return () => {}
        }, [groupOfFour])

        return (
          <>
            <div ref={domNodeRef} className="dice"></div>
            <button onClick={keepCoin}>Keep piece</button>
            <button onClick={unkeepCoin}>Unkeep piece</button>
            <br />
            <button
              onClick={() => {
                keepCoin()
                simulateGroupOfFourFound()
              }}
            >
              Keep 4eme piece
            </button>
            <button
              onClick={() => {
                unkeepCoin()
                simulateGroupOfFourLost()
              }}
            >
              Unkeep 4 eme piece
            </button>

            <TotalScore
              value={totalScoreDisplayed}
              scoreParticleMergedSignal={scoreParticleMergedSignal}
              totalScoreDomNodeRef={totalScoreDomNodeRef}
            />
            {scoreParticles.map((scoreParticle) => {
              return (
                <ScoreParticle
                  key={scoreParticle.id}
                  totalScoreDomNodeRef={totalScoreDomNodeRef}
                  scoreParticle={scoreParticle}
                />
              )
            })}
          </>
        )
      }

      const useScoreParticles = ({ minDelayBetweenParticles = 1000 } = {}) => {
        const [scoreParticles, scoreParticlesSetter] = React.useState([])

        const addScoreParticleToState = (scoreParticle) => {
          console.log(`adding score particle ${scoreParticle.id}`)
          scoreParticlesSetter([...scoreParticles, scoreParticle])
          return () => {
            console.log(`removing score particle ${scoreParticle.id}`)
            const scoreParticlesWithoutParticle = scoreParticles.filter(
              (scoreParticleCandidate) => scoreParticleCandidate !== scoreParticle,
            )
            scoreParticlesSetter(scoreParticlesWithoutParticle)
            // scoreParticlesSetter((scoreParticles) => {
            //   console.log(`score particle ${scoreParticle.id} removed`)
            //   return scoreParticles.filter(
            //     (scoreParticleCandidate) => scoreParticleCandidate !== scoreParticle,
            //   )
            // })
          }
        }

        const lastParticleAnimatedMsRef = React.useRef(null)
        const scoreParticleMergedSignal = useSignalEmitter()
        const addScoreParticle = ({ id, value, x, y }) => {
          const lastParticleAnimatedMs = lastParticleAnimatedMsRef.current
          lastParticleAnimatedMsRef.current = Date.now()
          const animationDelay = scoreParticleAnimationDelayGetter(
            lastParticleAnimatedMs,
            minDelayBetweenParticles,
          )
          console.log(`${id} animation delay is ${animationDelay}`)

          const scoreParticle = {
            id,
            value,
            x,
            y,
            animationDelay,
          }
          const removeScoreParticleFromState = addScoreParticleToState(scoreParticle)
          scoreParticle.onScoreParticleMerged = () => {
            scoreParticleMergedSignal.emit(scoreParticle)
            removeScoreParticleFromState()
          }
          // scoreParticle.onScoreParticleCanceled = () => {
          //   console.log(`${id} particle animation canceled`)
          // }
          return removeScoreParticleFromState
        }

        return [scoreParticles, addScoreParticle, scoreParticleMergedSignal]
      }

      const TotalScore = ({ value, scoreParticleMergedSignal, totalScoreDomNodeRef }) => {
        const scoreParticleMerged = useSignalListener(scoreParticleMergedSignal)

        React.useEffect(() => {
          if (!scoreParticleMerged) return

          const totalScoreDomNode = totalScoreDomNodeRef.current
          totalScoreDomNode.animate(
            [
              {
                transform: "scale(1.5)",
              },
            ],
            { duration: 300 },
          )
        }, [totalScoreDomNodeRef, scoreParticleMerged])

        const totalScoreAnimatedValue = useAnimateTransitionUsingJs(value, { duration: 600 })

        return (
          <div className="score">
            <p ref={totalScoreDomNodeRef} className="score--value">
              {totalScoreAnimatedValue ? totalScoreAnimatedValue.value : value}
            </p>
          </div>
        )
      }

      const ScoreParticle = ({ totalScoreDomNodeRef, scoreParticle }) => {
        const particleDomNodeRef = React.useRef()
        React.useEffect(() => {
          const particleDomNode = particleDomNodeRef.current
          const totalScoreDomNode = totalScoreDomNodeRef.current
          return animateScoreParticle({
            particleDomNode,
            totalScoreDomNode,
            x: scoreParticle.x,
            y: scoreParticle.y,
            delay: scoreParticle.animationDelay,
            oncancel: scoreParticle.onScoreParticleCanceled,
            onfinish: scoreParticle.onScoreParticleMerged,
          })
        }, [])

        return (
          <div ref={particleDomNodeRef} className="score-particle">
            {scoreParticle.value}
          </div>
        )
      }

      const animateScoreParticle = ({
        particleDomNode,
        totalScoreDomNode,
        x,
        y,
        duration = 800,
        delay = 0,
        oncancel = () => {},
        onfinish = () => {},
      }) => {
        const particleDomNodeRectangle = getDomNodeRectangle(particleDomNode)
        const totalScoreDomNodeRectangle = getDomNodeRectangle(totalScoreDomNode)

        const particleWidth = particleDomNodeRectangle.right - particleDomNodeRectangle.left
        const particleHeight = particleDomNodeRectangle.bottom - particleDomNodeRectangle.top
        const startX = x - particleWidth / 2
        const startY = y - particleHeight / 2
        const intermediateX = startX + 5
        const intermediateY = startY - particleHeight * 1.5
        const endX = totalScoreDomNodeRectangle.left
        const endY = totalScoreDomNodeRectangle.top

        particleDomNode.style.left = `${startX}px`
        particleDomNode.style.top = `${startY}px`

        if (debug) {
          printPointInDocument(
            { x: startX, y: startY },
            {
              autoRemove: false,
              color: "yellow",
            },
          )
          printPointInDocument(
            { x: intermediateX, y: intermediateY },
            {
              autoRemove: false,
              color: "orange",
            },
          )
          printPointInDocument(
            { x: endX, y: endY },
            {
              autoRemove: false,
              color: "red",
            },
          )
        }

        // en premier fait apparaitre avec opacité
        const animation = particleDomNode.animate(
          [
            {
              opacity: 0,
              visibility: "visible",
              transform: "translate(0px, 0px)",
            },
            {
              offset: 0.1,
              opacity: 1,
              // transform: "translate(0px, 0px)",
            },
            {
              offset: 0.4,
              opacity: 1,
              transform: `translate(${intermediateX - startX}px, ${
                intermediateY - startY
              }px) scale(1.2)`,
            },
            {
              transform: `translate(${endX - startX}px, ${endY - startY}px) scale(1.2)`,
            },
          ],
          {
            duration,
            delay,
            fill: "forwards",
          },
        )
        animation.onfinish = () => {
          onfinish()
        }

        return () => {
          oncancel()
          animation.cancel()
        }
      }

      const scoreParticleAnimationDelayGetter = (lastAnimationMs, minDelayBetweenParticles) => {
        if (!lastAnimationMs) {
          return 0
        }

        const nowMs = Date.now()
        const msEllapsedSinceLastParticle = nowMs - lastAnimationMs
        const msToWait = minDelayBetweenParticles - msEllapsedSinceLastParticle
        if (msToWait <= 0) {
          return 0
        }

        return msToWait
      }

      const domNodeToScoreParticlePosition = (domNode) => {
        const domNodeRectangle = getDomNodeRectangle(domNode)
        const centerPoint = getRectangleCenterPoint(domNodeRectangle)
        return centerPoint
      }

      ReactDOM.render(<App />, document.querySelector("#app"))
    </script>
  </body>
</html>
