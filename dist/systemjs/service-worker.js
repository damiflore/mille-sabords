self.generatedUrlsConfig={"assets/ArrrMateyBb-wn3-3d20259e.ttf":{versioned:!0},"assets/BarbeRouge-b4a9d8e9.png":{versioned:!0},"assets/boat-dc6ca6cf.png":{versioned:!0},"assets/CapitaineCrochet-0ce0da4f.png":{versioned:!0},"assets/card_1skull-47b3b46a.png":{versioned:!0},"assets/card_2skulls-61ce4149.png":{versioned:!0},"assets/card_2sword-challenge-5c1924fd.png":{versioned:!0},"assets/card_3sword-challenge-4097c59a.png":{versioned:!0},"assets/card_4sword-challenge-f3927ba3.png":{versioned:!0},"assets/card_animals-e97f74ef.png":{versioned:!0},"assets/card_chest-037b957f.png":{versioned:!0},"assets/card_coin-19c1c721.png":{versioned:!0},"assets/card_default-d777c0de.png":{versioned:!0},"assets/card_diamond-ae0da860.png":{versioned:!0},"assets/card_pirate-57c15344.png":{versioned:!0},"assets/card_small-1skull-3c9f4a9f.png":{versioned:!0},"assets/card_small-2skulls-683eae22.png":{versioned:!0},"assets/card_small-animals-b931298f.png":{versioned:!0},"assets/card_small-chest-b171aea9.png":{versioned:!0},"assets/card_small-coin-a99cbd8e.png":{versioned:!0},"assets/card_small-diamond-d3b35497.png":{versioned:!0},"assets/card_small-pirate-ada07362.png":{versioned:!0},"assets/card_small-sword-challenge-dc6ca6cf.png":{versioned:!0},"assets/card_small-witch-5e50e07c.png":{versioned:!0},"assets/card_witch-24c51955.png":{versioned:!0},"assets/card-rules-dialog-50665232.css":{versioned:!0},"assets/character-selection-181bd1c8.css":{versioned:!0},"assets/chest-ecf6979a.css":{versioned:!0},"assets/cursed-grid-d5dc17c3.png":{versioned:!0},"assets/dialog.base-81195bc9.css":{versioned:!0},"assets/dialog-8b512a79.css":{versioned:!0},"assets/dialog.wood-519851b1.css":{versioned:!0},"assets/dice_coin-37896c9d.png":{versioned:!0},"assets/dice_diamond-6c36ed54.png":{versioned:!0},"assets/dice_monkey-044ce09c.png":{versioned:!0},"assets/dice_parrot-21f5c4b5.png":{versioned:!0},"assets/dice_skull-271c6b85.png":{versioned:!0},"assets/dice_sword-f0ac96f9.png":{versioned:!0},"assets/dice-ongoing-401ead15.css":{versioned:!0},"assets/dice-b1c540cc.css":{versioned:!0},"assets/draw-card-dialog-5d3f49fd.css":{versioned:!0},"assets/favicon-25e95a00.png":{versioned:!0},"assets/footer-4991a0c0.css":{versioned:!0},"assets/game-configuration-ebf280f3.css":{versioned:!0},"assets/GinetteBoulette-de6a1ce1.png":{versioned:!0},"assets/header-4c28c2d6.css":{versioned:!0},"assets/home-2e7e167b.css":{versioned:!0},"assets/JackSparrow-f439b5cc.png":{versioned:!0},"assets/loadscreen-f1f98571.css":{versioned:!0},"assets/Luffy-59728a08.png":{versioned:!0},"assets/main-0218d392.css":{versioned:!0},"assets/metal-36435573.jpg":{versioned:!0},"assets/mille-sabord-cee7f4b1.css":{versioned:!0},"assets/mille-sabords.webmanifest":{versioned:!1,version:"913835fc"},"assets/MissFortune-4b135ade.png":{versioned:!0},"assets/pirate-hook-02-3db1b696.png":{versioned:!0},"assets/pirate-hook-02fba0b6.png":{versioned:!0},"assets/PirateTreasureDemo-4B3MB-febb1694.otf":{versioned:!0},"assets/pwa-icon-574c1c76.png":{versioned:!0},"assets/round-2b248ac6.css":{versioned:!0},"assets/round.score-00ca4100.css":{versioned:!0},"assets/s-d548d9f5.js":{versioned:!0},"assets/score-board-c673d856.css":{versioned:!0},"assets/sea-096e0699.jpg":{versioned:!0},"assets/settings-c7b8b010.css":{versioned:!0},"assets/skull-bottle-7c833fb2.png":{versioned:!0},"assets/skull-island-87ab7c27.css":{versioned:!0},"assets/skullsandcrossbones-70af14b1.ttf":{versioned:!0},"assets/star-rain-7a40ced1.css":{versioned:!0},"assets/start-player-round-dialog-2527853b.css":{versioned:!0},"assets/stone-417f342b.png":{versioned:!0},"assets/swords-disabled-124616f0.png":{versioned:!0},"assets/treasure-map-6ec97baa.png":{versioned:!0},"assets/win-treasure-7f39a7fa.png":{versioned:!0},"assets/witch-label-f95d3d2f.png":{versioned:!0},"assets/wood-box-fcdd41cc.jpg":{versioned:!0},"assets/wood-3c23f120.jpg":{versioned:!0},"assets/wood-1edfbf4b.png":{versioned:!0},"assets/wood2-15862f37.png":{versioned:!0},"App-9f27e59c.js":{versioned:!0},"importmap.prod-93bec16b.importmap":{versioned:!0},"main.component-5cb49070.js":{versioned:!0},"main-f9f3bcd5.js":{versioned:!0},"main.prod.html":{versioned:!1,version:"311ce392"}},self.config={};const{config:config}=self;config.cachePrefix="jsenv",config.manualUrlsConfig={"/":{}},config.shouldHandleRequest=(e,{requestWasCachedOnInstall:s})=>("GET"===e.method||"HEAD"===e.method)&&s,config.shouldCleanOnActivate=(e,s,{requestWasCachedOnInstall:a})=>!a,config.logLevel="warn",config.logsBackgroundColor="#ffdc00",config.navigationPreloadEnabled=!1,config.actions={ping:()=>"pong"},config.cachePrefix="mille-sabords";const assertContextLooksGood=()=>{const{generatedUrlsConfig:e}=self;if(void 0===e)self.generatedUrlsConfig={};else if("object"!=typeof e)throw new TypeError(`self.generatedUrlsConfig should be an object, got ${e}`);if(void 0===typeof config)throw new Error("config is not in scope, be sure to import sw.preconfig.js before sw.jsenv.js");const{manualUrlsConfig:s}=config;if("object"!=typeof s)throw new TypeError(`config.manualUrlsConfig should be an array, got ${s}`);const{cachePrefix:a}=config;if("string"!=typeof a)throw new TypeError(`config.cachePrefix should be a string, got ${a}`);if(0===a.length)throw new TypeError("config.cachePrefix must not be empty");const{shouldCleanOnActivate:n}=config;if("function"!=typeof n)throw new TypeError(`config.shouldCleanOnActivate should be a function, got ${n}`);const{shouldHandleRequest:r}=config;if("function"!=typeof r)throw new TypeError(`config.shouldHandleRequest should be a function, got ${r}`);const{logLevel:o}=config;if("string"!=typeof o)throw new TypeError(`config.logLevel should be a boolean, got ${o}`);const{logsBackgroundColor:t}=config;if("string"!=typeof t)throw new TypeError(`config.logsBackgroundColor should be a string, got ${t}`);const{navigationPreloadEnabled:c}=config;if("boolean"!=typeof c)throw new TypeError(`config.navigationPreloadEnabled should be a boolean, got ${c}`)},getUtil=()=>{const e={};e.createLogger=({logLevel:e,logsBackgroundColor:s})=>{const a=e=>(...a)=>console[e](...((...e)=>["%csw",`background: ${s}; color: black; padding: 1px 3px; margin: 0 1px`,...e])(...a)),n=a("debug"),r=a("info"),o=a("warn"),t=a("error"),c=()=>{};if("debug"===e)return{debug:n,info:r,warn:o,error:t};if("info"===e)return{debug:c,info:r,warn:o,error:t};if("warn"===e)return{debug:c,info:c,warn:o,error:t};if("error"===e)return{debug:c,info:c,warn:c,error:t};if("off"===e)return{debug:c,info:c,warn:c,error:c};throw new Error(`unknown logLevel, got ${e}`)},e.resolveUrl=e=>String(new URL(e,self.location));{e.responseUsesLongTermCaching=e=>{const a=e.headers.get("cache-control"),n=s(a);return n&&n>0};const s=e=>{if(!e||0===e.length)return null;const s=e.match(/([a-zA-Z][a-zA-Z_-]*)\s*(?:=(?:"([^"]*)"|([^ \t",;]*)))?/g)||[],n={};return Array.from(s).forEach((e=>{const s=e.split("=",2),[a]=s;let r=null;s.length>1&&(r=s[1].trim()),n[a.toLowerCase()]=r})),a(n["max-age"])},a=e=>{if(!e)return null;const s=Number.parseInt(e,10);return!Number.isFinite(s)||s<0?null:s}}{e.getCacheName=({cachePrefix:e})=>`${e}${c()}`;const s=36,a=4,n=Math.pow(s,a),r=(e,s)=>{var a=`000000000${e}`;return a.substr(a.length-s)},o=(()=>{const{crypto:e}=self;if(e){const s=Math.pow(2,32)-1;return()=>Math.abs(e.getRandomValues(new Uint32Array(1))[0]/s)}return Math.random})(),t=()=>r((o()*n<<0).toString(s),a),c=()=>`${(new Date).getTime().toString(s)}${`${t()}${t()}`}`}{e.readUrlConfig=()=>{const a={...self.generatedUrlsConfig,...config.manualUrlsConfig},n=[],r=[],o={};return s(a,((s,a)=>{a||(a={cache:!1}),!0===a&&(a={cache:!0});const{cache:t=!0,versioned:c=!1,alias:i}=a;t&&(n.push(s),c||r.push(s)),i&&(o[s]=e.resolveUrl(i))})),{urlsToCacheOnInstall:n,urlsToReloadOnInstall:r,urlMapping:o}};const s=(s,a)=>{const n=[];Object.keys(s).forEach((r=>{const o=e.resolveUrl(r);n.includes(o)||(n.push(o),a(o,s[r]))}))}}return e.redirectRequest=async(e,s)=>{const{mode:a}=e;if("navigate"!==a)return new Request(s,e);const n=e.clone(),{body:r,credentials:o,headers:t,integrity:c,referrer:i,referrerPolicy:l}=n,d=r?Promise.resolve(r):n.blob(),g=await d;return new Request(s,{body:g,credentials:o,headers:t,integrity:c,referrer:i,referrerPolicy:l,mode:"same-origin",redirect:"manual"})},e};assertContextLooksGood();const util=getUtil(),cacheName=util.getCacheName(config),logger=util.createLogger(config),{urlsToCacheOnInstall:urlsToCacheOnInstall,urlsToReloadOnInstall:urlsToReloadOnInstall,urlMapping:urlMapping}=util.readUrlConfig(config);logger.info(`cache key: ${cacheName}`);const install=async()=>{logger.info("install start");try{const e=urlsToCacheOnInstall.length;let s=0;await Promise.all(urlsToCacheOnInstall.map((async e=>{try{const a=urlsToReloadOnInstall.includes(e),n=new Request(e,{...a?{cache:"reload"}:{}});await fetchAndCache(n,{oncache:()=>{s+=1}})}catch(s){logger.warn(`cannot put ${e} in cache due to error while fetching: ${s.stack}`)}}))),s===e?logger.info(`install done (${e} urls added in cache)`):logger.info(`install done (${s}/${e} urls added in cache)`)}catch(e){logger.error(`install error: ${e.stack}`)}};self.addEventListener("install",(e=>{e.waitUntil(install())}));const handleRequest=async(e,s)=>{logger.debug(`received fetch event for ${e.url}`);try{const a=await self.caches.match(e);if(a)return logger.debug(`respond with response from cache for ${e.url}`),a;const n=await s.preloadResponse;if(n)return logger.debug(`respond with preloaded response for ${e.url}`),n}catch(s){return logger.warn(`error while trying to use cache for ${e.url}`,s.stack),fetch(e)}return logger.debug(`no cache for ${e.url}, fetching it`),fetchAndCache(e)},remapRequest=e=>{if(Object.prototype.hasOwnProperty.call(urlMapping,e.url)){const s=urlMapping[e.url];return logger.debug(`redirect request from ${e.url} to ${s}`),util.redirectRequest(e,s)}return e};self.addEventListener("fetch",(e=>{const s=remapRequest(e.request);if(config.shouldHandleRequest(s,{requestWasCachedOnInstall:urlsToCacheOnInstall.includes(s.url)})){const a=handleRequest(s,e);a&&e.respondWith(a)}}));const activate=async()=>{logger.info("activate start"),await Promise.all([enableNavigationPreloadIfPossible(),deleteOtherUrls(),deleteOtherCaches()]),logger.info("activate done")},enableNavigationPreloadIfPossible=async()=>{config.navigationPreloadEnabled&&self.registration.navigationPreload&&await self.registration.navigationPreload.enable()},deleteOtherUrls=async()=>{const e=await self.caches.open(cacheName),s=await e.keys();await Promise.all(s.map((async s=>{const a=await e.match(s);config.shouldCleanOnActivate(a,s,{requestWasCachedOnInstall:urlsToCacheOnInstall.includes(s.url)})&&(logger.info(`delete ${s.url}`),await e.delete(s))})))},deleteOtherCaches=async()=>{const e=await self.caches.keys();await Promise.all(e.map((async e=>{e!==cacheName&&e.startsWith(config.cachePrefix)&&(logger.info(`delete cache ${e}`),await self.caches.delete(e))})))};self.addEventListener("activate",(e=>{const s=activate();s&&e.waitUntil(s)}));const actions={skipWaiting:()=>{self.skipWaiting()},refreshCacheKey:async e=>{e=util.resolveUrl(e);return(await fetchAndCache(new Request(e,{cache:"reload"}))).status},addCacheKey:async e=>{e=util.resolveUrl(e);return(await fetchAndCache(e)).status},removeCacheKey:async e=>{e=util.resolveUrl(e);const s=await self.caches.open(cacheName);return await s.delete(e)},...config.actions};self.addEventListener("message",(async e=>{const{data:s}=e;if("object"!=typeof s)return;const{action:a}=s,n=actions[a];if(!n)return;const{payload:r}=s;let o,t;try{const e=await n(r,{cacheName:cacheName});o="resolved",t=e}catch(e){o="rejected",t=e}e.ports[0].postMessage({status:o,value:t})}));const fetchAndCache=async(e,{oncache:s}={})=>{const[a,n]=await Promise.all([fetchUsingNetwork(e),getCache()]);if(200===a.status){logger.debug(`fresh response found for ${e.url}, put it in cache and respond with it`);const r=await responseToResponseForCache(a),o=n.put(e,r);return s&&(await o,s()),a}return logger.warn(`cannot put ${e.url} in cache due to response status (${a.status})`),a},responseToResponseForCache=async e=>{const s=e.clone();if(!e.redirected)return s;const a="body"in s?Promise.resolve(s.body):s.blob(),n=await a;return new Response(n,{headers:s.headers,status:s.status,statusText:s.statusText})},fetchUsingNetwork=async e=>{const s=new AbortController,{signal:a}=s;try{return await fetch(e,{signal:a})}catch(e){throw s.abort(),e}},getCache=async()=>await self.caches.open(cacheName);
//# sourceMappingURL=service-worker.js.map